<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>A Cubic Barrier with Elasticity-Inclusive Dynamic Stiffness</title>
    <style>
      body {
        font-family: 'Microsoft YaHei', sans-serif;
        margin: 20px;
        background-color: black;
        font-size: 12pt;
      }
      .ori {
        margin-bottom: 20px;
        padding: 0.5rem 2rem 0.5rem 2rem;
        background-color: black;
        color: white;
        /* break-inside: avoid; */
      }
      .trans {
        margin-bottom: 20px;
        padding: 0.5rem 2rem 0.5rem 2rem;
        background-color: white;
        color: black;
        /* break-inside: avoid; */
      }
    </style>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
      .fig {
        margin: 1rem 0;
        text-align: center;
        background-color: #555;
        padding: 0.5rem 2rem 0.5rem 2rem;
      }
      .fig img {
        max-width: 100%;
        height: auto;
      }
      .fig figcaption {
        font-size: 0.9em;
        font-style: italic;
        color: #fff;
      }
      .algo {
        background: #f7f7f7;
        padding: 12px;
        border-radius: 8px;
        overflow: auto;
      }
      .algo_rev {
        padding: 12px;
        border-radius: 8px;
        overflow: auto;
        color: #bbb;
        background-color: #222;
      }
      .internal_fig_img {
        max-height: 15rem;
        max-width: 15rem;
      }
    </style>
  </head>
  <body>
    <div style="background-color: #333; color: wheat; padding: 0.2rem 1rem 0.2rem 1rem; margin-bottom: 1rem">
      翻译：<a href="https://github.com/NnWinter" style="color: wheat">@NnWinter <sup>(github)</sup></a
      ><br />
      纯个人学习交流使用，版权归原作者所有，如有侵权请联系删除。<br />
      翻译仅供参考，具体以原文为准。转载本翻译版本请注明出处及转载信息。<br />
      翻译由 AI 辅助完成。译者猜测内容的准确度会逐步提高(鉴于有更多前文推理)，因此靠后的内容或许相对更准确。<br />
      数学公式使用 图像解析+OCR 组合筛选，用数学标记语言重写(并非原文)。重写部分包括中文与英文，因此中英文部分皆有可能与原文有差异，无法保证100%准确。如果用于专业用途请务必多次检查。<br />
      翻译目的仅为让阅读英文困难的读者能更方便地了解论文内容，不能保证翻译质量。如发现错误欢迎指正，可以通过在Github上提交issue以进行修正。<br />
      也欢迎将本html中提取的内容翻译为其它语言，可以为学术做贡献。
    </div>
    <div class="trans">
      <h2>含弹性动态刚度的立方障碍函数</h2>
      作者：Ryoichi Ando（日本 ZOZO）
    </div>
    <div class="ori">
      <h2>A Cubic Barrier with Elasticity-Inclusive Dynamic Stiffness</h2>
      RYOICHI ANDO, ZOZO, Japan
    </div>
    <div class="fig">
      <img src="img/1.jpg" alt="Figure 4.4: Reef and Fishing Knots" style="max-width: 100%" />
      <figcaption>图 1：平结与渔人结示例 (注:被多次提及)</figcaption>
    </div>
    <div class="trans">
      图 1 (A) 五个圆柱壳体分别被扭转后再捆束成束；(B) 单个编织圆柱在扭转下形成复杂的屈曲纹理；(C) 一束很长的细缆被倾倒入碗中；(D) 飘带被倒入碗中，随后又受到下落球体的强烈撞击；(E) 一个渔结被拉紧；(F)
      八个柔软的“毛茸茸”小球被压缩后释放；(G) 一座纸牌屋被滚动球体轻触后坍塌；(H) 一只高速下落的重球将十张薄片猛砸到地面。 接触数峰值分别为：1.6835 亿（A）、1759 万（D）、649 万（C）、604 万（B）、563
      万（H）、289 万（F）。 视频每帧平均耗时分别为：194 秒（A）、745 秒（B）、247 秒（C）、184 秒（D）、3.30 秒（E）、196 秒（F）、5.04 秒（G）、77.35 秒（H）。
    </div>
    <div class="ori">
      Fig. 1. Five cylindrical shells are individually twisted and bundled together (A), A single woven cylinder is twisted forming intricate buckles (B), A set of lengthy strands are poured into a
      bowl (C), Fluttering ribbons are poured into a bowl followed by a strong impact from a falling sphere (D), A fishing knot is tightened (E), Eight squishy hairy balls are compressed and released
      (F), A house of cards collapses with a gentle touch by a rolling sphere (G), Ten sheets are smashed onto the ground by a fast falling heavy sphere (H). Peak contact counts are 168.35 million
      (A), 17.59 million (D), 6.49 million (C), 6.04 million (B), 5.63 million (H), 2.89 million (F). Average time per video frame is 194s (A), 745s (B), 247s (C), 184s (D), 3.30s (E), 196s (F), 5.04s
      (G), 77.35s (H).
    </div>
    <div class="trans">
      <p>
        本文提出了一种用于无穿透接触求解和应变限制的全新<strong>含弹性动态刚度的三次障碍函数</strong>。我们展示了该方法在对数障碍难以处理的紧致应变限制间隙中仍能有效扩展可行空间，
        并能实现高度可扩展的高接触密度仿真。
      </p>
      <p>
        <strong>CCS 概念：</strong>• 计算方法学 → 物理仿真。<br />
        <strong>附加关键词：</strong>碰撞，接触。
      </p>
      <p>
        <strong>ACM 引用格式：</strong><br />
        Ryoichi Ando. 2024. A Cubic Barrier with Elasticity-Inclusive Dynamic Stiffness. <em>ACM Transactions on Graphics</em> 43(6), 文章 224（2024 年 12 月），共 13 页。<br />
        https://doi.org/10.1145/3687908
      </p>
    </div>
    <div class="ori">
      <p>
        This paper presents a new cubic barrier with elasticity-inclusive dynamic stiffness for penetration-free contact resolution and strain limiting. We show that our method enlarges tight
        strain-limiting gaps where logarithmic barriers struggle and enables highly scalable contact-rich simulation.
      </p>
      <p>CCS Concepts: • Computing methodologies → Physical simulation. Additional Key Words and Phrases: collision, contact</p>
      <p>
        ACM Reference Format:<br />
        Ryoichi Ando. 2024. A Cubic Barrier with Elasticity-Inclusive Dynamic Stiffness. ACM Trans. Graph. 43, 6, Article 224 (December 2024), 13 pages.
        <br />https://doi.org/10.1145/3687908
      </p>
    </div>
    <div class="trans">
      <p>作者地址：Ryoichi Ando，ryoichi.ando@zozo.com，ZOZO，日本千叶。</p>
      <p>
        允许为个人或课堂用途免费制作本作品全部或部分内容的数字或纸质副本，前提是这些副本不用于盈利或商业利益，且在第一页标注本声明并附上完整引用。对于作者以外权利人所拥有版权的组成部分，必须予以尊重。注明来源的摘录是被允许的。除此之外的复制、再版、在服务器上发布或向名单分发，均需事先获得特定许可和/或支付费用。许可申请请联系：permissions@acm.org。
      </p>
      <p>©2024 版权归作品所有者/作者所有。出版权已许可给 ACM。0730-0301/2024/12-ART224 $15.00</p>
      <p>https://doi.org/10.1145/3687908</p>
    </div>
    <div class="ori">
      <p>Author’s address: Ryoichi Ando, ryoichi.ando@zozo.com, ZOZO, Chiba, Japan</p>
      <p>
        Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or
        commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored.
        Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from
        permissions@acm.org.
      </p>
      <p>©2024 Copyright held by the owner/author(s). Publication rights licensed to ACM. 0730-0301/2024/12-ART224 $15.00</p>
      <p>https://doi.org/10.1145/3687908</p>
    </div>
    <div class="trans">
      <h3>1 引言</h3>
      <p>
        精确的接触求解具有相当挑战性 [Kaufman et al. 2005; Takahashi and Batty 2021; Tomcin et al. 2014; Won and Lee 2019]。薄壳体尤为棘手，因为即便极小的穿透也会使整个仿真停滞， 陷于自相交而难以解缠
        [Baraff et al. 2003; Volino and Magnenat Thalmann 2006]；除非壳层的显式叠层顺序已知 [Buffet et al. 2019; Lee et al. 2023; Lewin 2018]。
        这使得纯体积式方法并不适合处理共维（codimensional）碰撞对象 [Allard et al. 2010; Chen et al. 2023; Faure et al. 2008; Tang et al. 2012]。当碰撞无法被解析时， 可以采用刚性冲击区 [Harmon et al.
        2008; Huh et al. 2001; Provot 1997]，将其刚化并把碰撞求解延迟到下一步 [Bridson et al. 2002; Ye et al. 2017]，或推迟到另一 个松弛循环，直至所有相交被消除 [Wu et al.
        2020]。不幸的是，这种方式并不能保证一定能解开所有相交 [Tang et al. 2018]。一种解决方案是在可行空间内使用不精确解作 为引导 [Wang et al. 2023]，或退回到内点法 [Wu et al.
        2020]。碰撞可通过求解三次方程 [Bridson et al. 2002; Provot 1997] 或奇偶校验（parity check）[Brochu et al. 2012; Wang et al. 2022] 来检测； 然而这两种方法都必须处理退化情形以及浮点数精度的限制
        [Wang et al. 2021; Wang 2014]。增量势接触（IPC）[Li et al. 2020, 2021] 通过在近乎接触的物体之间插入对数障碍， 保证无穿透的接触，从而规避上述问题。
      </p>
    </div>
    <div class="ori">
      <h3>1 INTRODUCTION</h3>
      <p>
        Exact contact resolution is challenging [Kaufman et al. 2005; Taka hashi and Batty 2021; Tomcin et al. 2014; Won and Lee 2019]. Thin shells are particularly difficult, as even slight
        penetration can halt the entire simulation, leaving it stuck and struggling to untangle from self-intersections [Baraff et al. 2003; Volino and Magnenat Thalmann 2006], except when the
        explicit order of shell layers is known [Buffet et al. 2019; Lee et al. 2023; Lewin 2018]. This makes purely volumetric approaches ill-suited for codimensional collid ers [Allard et al. 2010;
        Chen et al. 2023; Faure et al. 2008; Tang et al. 2012]. If collisions are unresolvable, one may resort to a rigid impact zone [Harmon et al. 2008; Huh et al. 2001; Provot 1997], rigidifying
        and delaying the collision resolution to the next step [Bridson et al. 2002; Ye et al. 2017] or deferring it to another relaxation loop until all intersections are resolved [Wu et al. 2020].
        Unfortunately, there is no guarantee that all intersections will be resolved in this man ner [Tang et al. 2018]. One solution is to use the inexact solution as guidance within the admissible
        space [Wang et al. 2023] or fall back to the interior point method [Wu et al. 2020]. Collisions are found via cubic equations [Bridson et al. 2002; Provot 1997] or a parity check [Brochu et
        al. 2012; Wang et al. 2022]. However, both methods need to deal with degenerate cases and limitations in floating-point accuracy [Wang et al. 2021; Wang 2014]. The incremental potential
        contact (IPC) [Li et al. 2020, 2021] circumvents the issues by inserting a logarithmic barrier between objects that are nearly touching to ensure penetration-free contacts.
      </p>
    </div>
    <div class="trans">
      <p>
        <strong>但有个问题。</strong> 当使用牛顿法最小化对数障碍时，按“力/曲率”得到的搜索方向在间隙趋近于零附近会变得极其微小。Huang 等人 [2024] 首次指出这一问题，并提出对曲率进行
        clamping（夹紧）。该做法避免了搜索方向的锁死，但会产生过大的更新方向。更多讨论见补充材料。Lan 等人 [2023] 将计算域着色为多个互不相邻的子域，
        对每个颜色并行精确求解，并合并迭代直至全局收敛。这样做可避免锁死方向影响整次更新，但根本问题仍未解决。
      </p>
    </div>
    <div class="ori">
      The Problem. When logarithmic barriers are minimized with a Newton’s solver, the search direction obtained by dividing the force by curvature yields an extremely small magnitude near gap zero.
      Huang et al. [2024] were the first to identify this issue and proposed clamping the curvature. This prevents search direction locking but instead produces excessively large directions. This is
      more discussed in the supplementary material. Lan et al. [2023] segregated domains into multiple non-adjacent colors, solving each color exactly in parallel, and merged them until global
      convergence was achieved. This way, locked search directions do not affect the entire update, but the inherent issue remains.
    </div>
    <div class="trans">
      <h3>1.1 我们的方法（Our Solution）</h3>

      <p>我们从一个<strong>弱三次障碍函数</strong>开始：</p>

      <p>
        \[ \psi_{\text{weak}}(g_i,\ \hat g_i,\ \kappa_i)= \begin{cases} -\dfrac{2\,\kappa_i}{3\,\hat g_i}\,\bigl(g_i-\hat g_i\bigr)^{3}, & \text{若 } g_i \le \hat g_i,\\[6pt] 0, & \text{否则。}
        \end{cases} \tag{1} \] 其中，\(g_i\) 表示相对于第 \(i\) 个约束的间隙距离；\(\kappa_i\) 与 \(\hat g_i\) 分别表示该约束的刚度常数与最大间隙。
      </p>

      <p>
        上式在 \(g_i=\hat g_i\) 处为 \(C^2\) 连续，且在临界点附近给出的搜索方向既不会过小也不会过大。代价是：该替换使能量在 \(g=0\) 处 不再发散为无穷。我们首先尝试将 \(\kappa_i\) 重新解释为
        \(\mathbf{x}\)（网格顶点向量）的函数，并令 \(\kappa_i(\mathbf{x})\to\infty\) 当 \(g_i\to0\)。
        然而这会再次引入搜索方向锁死问题。为解决此问题，我们采用<strong>半隐式</strong>做法：在计算能量势的导数时，把 \(\kappa_i(\mathbf{x})\) 视为常数。 这样一来，搜索方向锁死不再成为问题。
      </p>

      <p>在全文中，我们使用上横线记号 \(\bar{\kappa}_i\) 表示以半隐式方式评估的变量。求解器中的不同 \(\bar{\kappa}_i\) 更新顺序见第 3 节。 本文有两项关键贡献：</p>
      <ul>
        <li>一种改进应变限制的三次能量；</li>
        <li>一种基于弹性能量<strong>动态评估</strong>约束刚度的方法，能够稳健地扩大接触间隙。</li>
      </ul>
    </div>
    <div class="ori">
      <h3>1.1 Our Solution</h3>

      <p>We begin with a weak cubic barrier:</p>

      <p>
        \[ \psi_{\text{weak}}(g_i,\ \hat g_i,\ \kappa_i)= \begin{cases} -\dfrac{2\,\kappa_i}{3\,\hat g_i}\,\bigl(g_i-\hat g_i\bigr)^{3}, & \text{if } g_i \le \hat g_i,\\[6pt] 0, & \text{otherwise.}
        \end{cases} \tag{1} \] where \(g_i\) denotes the gap distance w.r.t. the \(i\)-th constraint, and \(\kappa_i\) and \(\hat g_i\) denote its stiffness constant and maximal gap, respectively.
      </p>

      <p>
        The above energy is \(C^2\) at \(g_i=\hat g_i\) and yields search directions that are neither too small nor too large near the critical point. The cost we pay is voiding the desirable property
        of the energy being infinite at gap zero. We first attempt to fix this by reinterpreting \(\kappa_i\) as a function of \(\mathbf{x}\) (the vector of mesh vertices) and letting
        \(\kappa_i(\mathbf{x})\to\infty\) as \(g_i\to0\). Unfortunately, this again introduces search-direction locking. To resolve this, we employ a semi-implicit approach: we treat
        \(\kappa_i(\mathbf{x})\) as constant when computing derivatives of its energy potential. With this, search-direction locking is no longer an issue.
      </p>

      <p>
        Throughout the paper, we use the bar notation \(\bar{\kappa}_i\) to indicate a semi-implicit evaluation. The ordering of different \(\bar{\kappa}_i\) updates in our solver is covered in
        Section 3. Our two key contributions are:
      </p>
      <ul>
        <li>A cubic energy that improves strain limiting; and</li>
        <li>A dynamically evaluated constraint stiffness using elasticity energies, which robustly enlarges the contact gap.</li>
      </ul>
    </div>

    <div class="trans">
      <h3>2 相关工作（Related Work）</h3>

      <p>
        碰撞求解通常包含四个环节：(a) 剔除（culling） [Bridson et al. 2002; Lan et al. 2022; Li et al. 2020]， (b) 检测（detection）[Brochu et al. 2012; Wang et al. 2022, 2021]， (c)
        解析/求解（resolve）[Baraff et al. 2003; Chen et al. 2023; Kim and Eberle 2022; Ye et al. 2017]， 以及 (d) 能量（energies）[Kim and Eberle 2022; McAdams et al. 2011; Zhao et al. 2022a]。
        更全面的综述可参见 Andrews et al. [2022]。下文将间隙记作 \(g\) 或 \(g_i\)。
      </p>
    </div>
    <div class="ori">
      <h3>2 RELATED WORK</h3>

      <p>
        Contact resolution consists of four parts: (a) culling [Bridson et al. 2002; Lan et al. 2022; Li et al. 2020], (b) detection [Brochu et al. 2012; Wang et al. 2022, 2021], (c) resolve [Baraff
        et al. 2003; Chen et al. 2023; Kim and Eberle 2022; Ye et al. 2017], and (d) energies [Kim and Eberle 2022; McAdams et al. 2011; Zhao et al. 2022a]. We refer readers to the survey by Andrews
        et al. [2022]. Below, we may simply write a gap as \(g\) or \(g_i\).
      </p>
    </div>
    <div class="trans">
      <h4>2.1 对数障碍函数（Logarithmic Barrier Functions）</h4>

      <p>对数障碍（如 Chen et al. 2022; Huang et al. 2024; Lan et al. 2023; Li et al. 2020, 2021; Zhao et al. 2022a）是最相关的一类方法。 例如 Li et al. [2021] 给出的形式为</p>

      <p>\[ \psi_{\ln}(g)= \begin{cases} -\,\kappa\,(g-\hat g)^{2}\,\ln\!\bigl(g/\hat g\bigr), & \text{若 } g \le \hat g,\\[6pt] 0, & \text{否则。} \end{cases} \tag{2} \]</p>

      <p>
        除了前述“搜索方向锁死”之外，我们的方法与其另一个重要区别在于<strong>刚度选择</strong>。Li et al. [2020] 通过平衡两类力来选取 \(\kappa\)。 设 \(\mathbf{f}_{\text{contact}}\) 与
        \(\mathbf{f}_{\text{ext}}\) 分别为接触力与外力（其中 \(\mathbf{f}_{\text{contact}}\) 为不含刚度系数的障碍力）， 其目标是
      </p>

      <p>\[ \kappa \;=\; \arg\min_{\kappa}\, \tfrac{1}{2}\,\bigl\lVert \mathbf{f}_{\text{ext}}+\kappa\,\mathbf{f}_{\text{contact}}\bigr\rVert^{2}. \]</p>

      <p>对 \(\kappa\) 求导，并代入 \(\mathbf{f}_{\text{ext}}=-\nabla\Psi_{\text{total}}\) 后令其为零，可得</p>

      <p>\[ \kappa \;=\; \dfrac{\mathbf{f}_{\text{contact}}\!\cdot\!\nabla\Psi_{\text{total}}}{\lVert \mathbf{f}_{\text{contact}}\rVert^{2}}. \]</p>

      <p>
        该做法可能产生无效取值。为避免此问题，他们设定了上下界：先在 \(g=10^{-8}\hat g\) 处计算最大曲率 \(c_{\max}\)， 再令下界 \(\kappa_{\min}=10^{11}\,\bar m / c_{\max}\)（\(\bar m\)
        为集总质量），上界 \(\kappa_{\max}=100\,\kappa_{\min}\)。 此策略还需额外的安全处理：当 \(g&lt;10^{-9}\hat g\) 且在相邻牛顿步之间还在减小时，需要将 \(\kappa\) 加倍。 另外，如何选择合适的
        \(\kappa\) 在实践中仍被报道为困难 [Shen et al. 2024]。
      </p>

      <p>与之相比，我们的刚度选择具有以下差异：</p>
      <ul>
        <li><strong>完全无参数</strong>：不涉及 \(10^{-9}\)、\(10^{11}\)、或 \(100\) 等常数；</li>
        <li>不设 \(\kappa\) 的上下界；</li>
        <li>不需要“将刚度加倍”等兜底策略。</li>
      </ul>

      <p>
        相较于 IPC [Li et al. 2020] 的另一处不同是：我们采用基于<strong>固定接触法线</strong>的距离评估（详见补充材料）， 因而不需要三角形-点与边-边距离的完整 Hessian，这些在分析上更复杂 [Shi and Kim
        2023]，且常需平滑化处理 [Huang et al. 2024]。
      </p>
    </div>
    <div class="ori">
      <h4>2.1 Logarithmic Barrier Functions</h4>

      <p>
        Logarithmic barriers [Chen et al. 2022; Huang et al. 2024; Lan et al. 2023; Li et al. 2020, 2021; Zhao et al. 2022a] are among the most relevant counterparts. An example from Li et al. [2021]
        is
      </p>

      <p>\[ \psi_{\ln}(g)= \begin{cases} -\,\kappa\,(g-\hat g)^{2}\,\ln\!\bigl(g/\hat g\bigr), & \text{if } g \le \hat g,\\[6pt] 0, & \text{otherwise.} \end{cases} \tag{2} \]</p>

      <p>
        Aside from search-direction locking, another difference from our method is how stiffness \(\kappa\) is selected. Li et al. [2020] proposed to balance two forces. Let
        \(\mathbf{f}_{\text{contact}}\) and \(\mathbf{f}_{\text{ext}}\) be contact and external forces, where \(\mathbf{f}_{\text{contact}}\) is a barrier force without a stiffness coefficient. They
        choose
      </p>

      <p>\[ \kappa \;=\; \arg\min_{\kappa}\, \tfrac{1}{2}\,\bigl\lVert \mathbf{f}_{\text{ext}}+\kappa\,\mathbf{f}_{\text{contact}}\bigr\rVert^{2}. \]</p>

      <p>Taking a derivative w.r.t. \(\kappa\), substituting \(\mathbf{f}_{\text{ext}}=-\nabla\Psi_{\text{total}}\), and setting it to zero yields</p>

      <p>\[ \kappa \;=\; \dfrac{\mathbf{f}_{\text{contact}}\!\cdot\!\nabla\Psi_{\text{total}}}{\lVert \mathbf{f}_{\text{contact}}\rVert^{2}}. \]</p>

      <p>
        As reported, this may yield invalid values. To avoid them, lower and upper bounds are defined. First, a maximum curvature \(c_{\max}\) is computed at \(g=10^{-8}\hat g\). With \(c_{\max}\)
        defined, the lower bound is set to \(\kappa_{\min}=10^{11}\,\bar m / c_{\max}\), where \(\bar m\) is a lumped mass. The upper bound is then \(\kappa_{\max}=100\,\kappa_{\min}\). This strategy
        needs additional care: when \(g\) becomes below \(10^{-9}\hat g\) and is also decreasing between Newton steps, \(\kappa\) needs to be doubled. Moreover, choosing an adequate \(\kappa\)
        reportedly remains difficult [Shen et al. 2024].
      </p>

      <p>Our stiffness selection differs in the following aspects:</p>
      <ul>
        <li>It is parameter-free (no numbers such as \(10^{-9}\), \(10^{11}\), or \(100\));</li>
        <li>It does not set any lower or upper bounds for \(\kappa\);</li>
        <li>It does not require fail-safes such as doubling stiffness.</li>
      </ul>

      <p>
        Another difference from IPC [Li et al. 2020] is that, since we employ a distance evaluation using a fixed contact normal (see supplementary), we do not require full Hessians of triangle-point
        and edge-edge distances, which introduce analytical complexity [Shi and Kim 2023] and require mollification [Huang et al. 2024].
      </p>
    </div>
    <div class="trans">
      <h4>2.2 二次能量（Quadratic Energies）</h4>

      <p>
        二次能量 [Baraff and Witkin 1998; Bridson et al. 2002; Kim and Eberle 2022; McAdams et al. 2011] 形如 \(\psi_{\text{quad}}(g)=\kappa\,(g-\hat g)^2/2\)。 与式 (2) 不同，当定义为 \(g\ge \hat g\)
        时 \(\psi_{\text{quad}}(g)=0\)，二次能量在 \(g=\hat g\) 处通常不是 \(C^2\) 连续。 Tang et al. [2012] 通过<strong>连续惩罚力</strong>来处理：考察步与步之间的路径，并对“沿轨迹的穿透量”做积分。
        这在一定程度上缓解问题，但会增加复杂度，使其不易与隐式格式结合。
      </p>

      <p>
        Harmon et al. [2009] 也注意到这一点并提出了<strong>累积的二次能量层</strong>：逐步叠加多项不同斜率的二次项，使得当 \(g\to0\) 时障碍趋于无穷。
        我们的方法与其主要差别在于：我们显式考虑了<strong>动态弹性</strong>，而他们仅考虑间隙项。
      </p>
    </div>
    <div class="ori">
      <h4>2.2 Quadratic Energies</h4>

      <p>
        Quadratic energies [Baraff and Witkin 1998; Bridson et al. 2002; Kim and Eberle 2022; McAdams et al. 2011] take the form \(\psi_{\text{quad}}(g)=\kappa\,(g-\hat g)^2/2\). Unlike (2), quadratic
        energies are not \(C^2\) continuous at \(g=\hat g\) when \(\psi_{\text{quad}}(g)=0\) for \(g\ge\hat g\). Tang et al. [2012] addressed the issue through continuous penalty forces: instead of
        using only the current state, they examine the path between steps and integrate the penetration along the trajectory. This may mitigate the issue to some extent, but at the cost of added
        complexity, making it nontrivial to employ implicit formulations.
      </p>

      <p>
        Harmon et al. [2009] also recognized this issue and proposed cumulative quadratic energy layers. Incrementally, multiple quadratic terms with different slopes are added, ensuring that the
        barrier approaches infinity as the gap diminishes to zero. The main difference is that ours considers dynamic elasticity, while theirs only considers the gap.
      </p>
    </div>
    <div class="trans">
      <h4>2.3 约束优化（Constrained Optimization）</h4>

      <p>
        无穿透动力学可用多种约束形式来求解：活动集（active set）[Verschoor and Jalba 2019]、梯度下降 [Tang et al. 2018]、 原-对偶下降 [Macklin et al. 2020]、投影法 [Harmon et al. 2008; Kaufman et al.
        2008; Müller et al. 2007; Wu et al. 2020] 等。 含拉格朗日乘子的优化往往引入额外自由度，并在与其他力耦合时导致不定系统；虽可转化为对称正定系统 [Takahashi and Batty 2022]，
        但要么自由度增多，要么系统更稠密。另一类替代方案是 ADMM [Overby et al. 2017] 及其变体 [Macklin et al. 2016]。 我们的方法可被视为投影动力学（projective
        dynamics）的一种变体：在一次全局求解（牛顿步）之后，对<strong>刚度进行投影</strong>
        ——即作半隐式评估 [Bouaziz et al. 2014]，因而与其在形式上有相似之处。
      </p>
      <p>
        还可以采用<strong>无 Hessian 投影（Hessian-free projection）</strong>方法 [Bouaziz et al. 2014; Macklin et al. 2016; Müller et al. 2007]， 该方法仅使用一阶导数。然而，在模拟诸如<strong
          >近乎不可伸长的布料</strong
        >
        这类高刚度系统时，该方法通常需要较长的收敛时间。
      </p>

      <p>
        一个例外是 Lan 等人 [2023] 的工作，他们展示了可以利用
        <strong>着色 Gauss–Seidel 方法（colored Gauss–Seidel method）</strong>
        来求解刚性系统。
      </p>

      <p>
        Wang 等人 [2023] 则提出了一种<strong>双向（two-way）方法</strong>： 先对约束优化进行非精确求解，再将该结果作为引导， 在可行空间内保守地更新变量。 这种思想与<strong
          >内点法（interior-point method）</strong
        >相似， 也是我们的方法所采用的思路。
      </p>
    </div>
    <div class="ori">
      <h4>2.3 Constrained Optimization</h4>

      <p>
        Penetration-free dynamics can be solved via constrained formulations such as the active set method [Verschoor and Jalba 2019], gradient descent [Tang et al. 2018], primal/dual descent [Macklin
        et al. 2020], and projection methods [Harmon et al. 2008; Kaufman et al. 2008; Müller et al. 2007; Wu et al. 2020]. Constrained optimizations with Lagrangian multipliers introduce extra
        degrees of freedom and lead to indefinite systems when solved together with other forces. Such systems can be converted into symmetric positive definite [Takahashi and Batty 2022]; however,
        this results in either increased DoFs or denser systems. Another alternative is ADMM [Overby et al. 2017] or its variants [Macklin et al. 2016]. Our method can be seen as a variant of
        projective dynamics in the sense that, after a global solve (the Newton step), we <em>project</em> stiffness (a semi-implicit evaluation) [Bouaziz et al. 2014], and as such, it shares some
        similarities.
      </p>
      <p>
        One may use a <strong>Hessian-free projection</strong> [Bouaziz et al. 2014; Macklin et al. 2016; Müller et al. 2007], which only utilizes first-order derivatives. However, simulating stiff
        systems such as nearly inextensible clothes with this method requires a long convergence time. An exception is the work of <strong>Lan et al. [2023]</strong>, which showed that a
        <strong>colored Gauss-Seidel method</strong> can be leveraged to solve stiff systems. <strong>Wang et al. [2023]</strong> introduced a <strong>two-way approach</strong>
        that solves constrained optimization inexactly and uses it as guidance to conservatively update variables within an admissible space, similar to the interior point method, which our method
        also employs.
      </p>
    </div>
    <!-- ================= 2.4 Nitsche’s Method ================= -->
    <div class="trans">
      <h4>2.4 Nitsche 方法</h4>
      <p>
        Nitsche 方法已被证明是处理机械工程中接触问题的有力工具 [Chouly et&nbsp;al. 2017, 2022; Gustafsson et&nbsp;al. 2020]。 与纯惩罚法不同，Nitsche
        方法还加入了用于<strong>分离接触体</strong>的“虚功”项。 其结果是：用于接触施加的刚度参数 <span>\(\gamma\)</span> 无需设置得很大即可实现接触解析，
        整个系统因而只表现为<strong>轻度刚性</strong>，线性方程组更易求解。
      </p>
      <p>
        我们的方法与 Nitsche 方法有相似之处：两者都包含<strong>动态评估</strong>的弹性项； 但 Nitsche 方法仍需要选择稳定化参数，且 <span>\(\gamma\)</span> 往往依据离散化
        参数（如网格单元尺寸的平方倒数）来设定 [Griebel and Schweitzer&nbsp;2003; Sanders et&nbsp;al.&nbsp;2009]。 相比之下，我们的方法<strong>无需任何关于场景或离散化的先验知识</strong>即可确定刚度。
      </p>
    </div>
    <div class="ori">
      <h4>2.4 Nitsche’s Method</h4>
      <p>
        Nitsche’s method has proven to be a powerful tool for handling contacts in mechanical engineering [Chouly et al. 2017, 2022; Gustafsson et al. 2020]. In addition to a purely penalty-based
        method, Nitsche’s method also adds a virtual work needed to separate two touching objects. A consequence is that their stiffness \(\gamma\) does not need to be set high to enforce contact
        resolution. This makes the entire system mildly stiff, making the linear system tractable.
      </p>
      <p>
        Our work shares some similarity with Nitsche’s method in that both methods include elastic terms that are dynamically evaluated, but Nitsche’s method still requires stabilizer parameter
        selection, with \(\gamma\) often chosen based on discretization parameters such as the squared inverse of element size [Griebel and Schweitzer 2003; Sanders et al. 2009]. In contrast, our
        method determines stiffness without any prior knowledge of the scene or discretization.
      </p>
    </div>

    <!-- ================= 2.5 Strain Limiting ================= -->
    <div class="trans">
      <h4>2.5 应变限制（Strain Limiting）</h4>
      <p>
        应变限制最初由 Provot&nbsp;[1997] 提出，并由 Bridson et&nbsp;al.&nbsp;[2002] 在计算机图形学中推广。 这两种方法基于<strong>显式积分</strong>，因此可扩展性受限。为此，Goldenthal
        et&nbsp;al.&nbsp;[2007] 提出一种<strong>半隐式</strong>方法，将问题表述为投影式的约束求解器；Jin et&nbsp;al.&nbsp;[2017]
        将其进一步改写为<strong>不等式约束</strong>，并证明与其纠正所有边长相等的做法相比，只纠正被拉长的边 能产生更细致的皱褶并避免膜锁定（membrane locking）。
      </p>
      <p>
        总体而言，<strong>精确满足</strong>应变限制约束的代价很高。Wang et&nbsp;al.&nbsp;[2010] 提出多分辨率求解器以加速收敛；Kim et&nbsp;al.&nbsp;[2012] 提出远程附着技术以在实时应用中近似不可伸长性。
        应变限制不仅适用于布料，也被应用到头发 [Müller et&nbsp;al.&nbsp;2012]、丝带 [Shen et&nbsp;al.&nbsp;2015] 和细杆 [Zhao et&nbsp;al.&nbsp;2022b]。
        以上许多方法以<strong>边</strong>为中心，控制单条边的拉伸变形。 Thomaszewski et&nbsp;al.&nbsp;[2009] 则提出连续体方法，可分别对<strong>拉伸</strong>与<strong>剪切</strong>设置限值并精确控制。
        最后，Li et&nbsp;al.&nbsp;[2021] 使用<strong>对数障碍不等式</strong>能量实现各向异性与各向同性的应变限制， 从而与弹性能量、碰撞能量实现紧耦合。
      </p>
    </div>
    <div class="ori">
      <h4>2.5 Strain Limiting</h4>
      <p>
        Strain limiting was initially advocated by Provot [1997] and popularized in graphics by Bridson et al. [2002]. Both methods are based on explicit integration, which can limit scalability. To
        address this, Goldenthal et al. [2007] proposed a semi-implicit method that formulates the problem as a projection constraint solver. This technique was further modified to inequality
        constraints by Jin et al. [2017]. They demonstrated that instead of using equality constraints, correcting only elongated edges would produce more detailed wrinkles and avoid membrane locking.
      </p>
      <p>
        In general, achieving exact satisfaction of strain limiting constraints is computationally expensive. Wang et al. [2010] proposed a multi-resolution solver to accelerate the convergence. Kim
        et al. [2012] introduced a long-range attachment technique that approximates inextensibility for real-time applications. The application of strain limiting is not limited to cloth; it is also
        applied for hair [Müller et al. 2012], ribbon [Shen et al. 2015] and rods [Zhao et al. 2022b]. Many of the above are edge-based, focusing on controlling stretch deformations along individual
        edges. Thomaszewski et al. [2009] proposed a continuum-based strain limiting technique that allows for accurate control of stretch and shear deformations with individual limits. Finally, Li et
        al. [2021] introduced both anisotropic and isotropic strain limiting using a logarithmic barrier inequality constraint energy, which enables tight coupling with elasticity and collision
        energies.
      </p>
    </div>

    <!-- ================= 2.6 Yarn-Level Contact ================= -->
    <div class="trans">
      <h4>2.6 纱线级接触（Yarn-Level Contact）</h4>
      <p>
        图形学中对纱线级碰撞的研究始于 Kaldor et&nbsp;al.&nbsp;[2008]，其引入了一个独特的碰撞能量： \[ \psi(g)=\frac{1}{g^{2}}+g^{2}, \] 表达“纱线之间既不能过近，也要保持一定间隙”的偏好。
        纱线级碰撞涉及的接触数目庞大，计算代价高。为降低代价，后续工作通过<strong>线性化</strong>来高效评估接触力 [Kaldor et&nbsp;al.&nbsp;2010]。
      </p>
      <p>
        Yuksel et&nbsp;al.&nbsp;[2012] 提出自适应时间步长以避免“穿透拉出”（pull-through，纱线隧穿伪影）：
        他们不解多元非线性方程，而是在纱线周围放置可细分的球体；当球体发生交叉即提示可能的拉出，因而相应减小步长。 Cirio et&nbsp;al.&nbsp;[2014] 在已知编织图案的前提下，将 Sueda
        et&nbsp;al.&nbsp;[2011] 的方法扩展到机织物； 同时，对远距离纱线-纱线碰撞，他们在布面周围构造一层薄的有符号场，用其数值来检测碰撞。 Cirio et&nbsp;al.&nbsp;[2017]
        进一步将“利用已知编织/针织图案”的思想泛化，用以模拟多种织物。
      </p>
      <p>
        尽管有上述技术，要<strong>精确</strong>模拟纱线级接触仍然代价高昂。 为缓解该问题，可对纱线变形进行<strong>均匀化</strong>处理：在弹性动力学层面 [Sperl et&nbsp;al.&nbsp;2020]、 力学层面 [Sperl
        et&nbsp;al.&nbsp;2021]，以及借助机器学习 [Feng et&nbsp;al.&nbsp;2024]。
      </p>
    </div>
    <div class="ori">
      <h4>2.6 Yarn-Level Contact</h4>
      <p>
        Yarn-level collisions in graphics started with the work of Kaldor et al. [2008], which introduced a unique collision energy: \(\psi(g)=1/g^{2}+g^{2}\), encoding that yarns should not be too
        close to each other but separated by some margin. Yarn-level collisions involve a large number of contacts and can be expensive. To mitigate this cost, contact force evaluation is made
        efficient through linearization [Kaldor et al. 2010].
      </p>
      <p>
        Yuksel et al. [2012] proposed an adaptive time-stepping approach to prevent pull-through, which refers to tunneling artifacts of yarns. Instead of solving multivariate nonlinear equations,
        they propose to place subdividable spheres. The crossing spheres indicate the possibility of pull-throughs, and as such, the step size is reduced accordingly. Cirio et al. [2014] extended the
        method of Sueda et al. [2011] for woven fabrics based on explicit knowledge of the woven pattern. Additionally, for distant yarn-yarn collisions, they created a thin signed field around the
        fabric sheet, and its value was used to detect collisions. Cirio et al. [2017] generalized the concept of utilizing explicit knowledge about the knitted pattern to simulate various types of
        fabrics.
      </p>
      <p>
        Despite the aforementioned techniques, accurately simulating yarn-level contact remains computationally expensive. This limitation is addressed via the homogenization of yarn deformations
        elastodynamically [Sperl et al. 2020], mechanically [Sperl et al. 2021] and with machine learning [Feng et al. 2024].
      </p>
    </div>

    <!-- ================= 3 METHOD OVERVIEW & 3.1 ================= -->
    <div class="trans">
      <h3>3 方法概览（Method Overview）</h3>
      <p>我们的方法包含两项关键技术：<strong>三次能量</strong>与<strong>包含弹性的动态刚度</strong>，它们各自产生不同的实际效果：</p>
      <ul>
        <li>我们的三次能量最适合<strong>间隙极小</strong>的情景（如应变限制）。 实验显示，其相较对数障碍的优势在接触处理中不明显，但在这些情形下仍表现稳健。</li>
        <li>我们的“含弹性”动态刚度在<strong>接触</strong>问题上最为有效：它能稳健地扩大接触间隙，免除手动调参。</li>
      </ul>

      <h4>3.1 目标函数（Objective Function）</h4>
      <p>我们的求解器继承了 CIPC [Li et&nbsp;al.&nbsp;2021] 的许多组件，因此这里只强调关键差异， 实现细节见补充材料。我们的目标是最小化：</p>
      <p>
        \[ \Psi_{\text{total}}(\mathbf{x}) \;=\; \Psi_{\text{dyn}}(\Delta t,\ \mathbf{x}) \;+\; \sum_{i} \Psi_{\text{weak}}\!\bigl(g_i,\ \hat g,\ \bar{\kappa}_i\bigr), \tag{3} \] 其中 \(\mathbf{x}\)
        为网格顶点；\(\Psi_{\text{dyn}}\) 编码与步长 \(\Delta t\) 相关的惯性与弹性能量 [Martin et&nbsp;al.&nbsp;2011]（如超弹与弯曲）；\(\Psi_{\text{weak}}\) 编码接触、边界条件与应变限制。
        再次强调，\(\bar{\kappa}\) 在<strong>每一步牛顿迭代</strong>、计算各类导数时以半隐式方式更新， 这也意味着目标函数本身会在每次牛顿步之间发生轻微变化。
      </p>
    </div>

    <div class="ori">
      <h3>3 METHOD OVERVIEW</h3>
      <p>Key highlights of our method consist of two techniques: a cubic function and elasticity-inclusive dynamic stiffness, each with distinct practical effects</p>
      <ul>
        <li>
          Our cubic energy is best suited for scenarios where gaps become extremely small, such as in strain limiting. Our experiments show that its superior effects over logarithmic barriers are not
          observed in contact handling, but it still robustly performs in these cases.
        </li>
        <li>Our elasticity-inclusive stiffness is most effective for contacts, as it robustly enlarges contact gaps, eliminating the need for manual parameter tuning.</li>
      </ul>

      <h4>3.1 Objective Function</h4>
      <p>
        Our solver inherits many components from CIPC [Li et al. 2021]; hence, we only focus on key differences. Implementation details are provided in the supplementary material. Our goal is to
        minimize the following objective
      </p>
      <p>
        \[ \Psi_{\text{total}}(\mathbf{x}) \;=\; \Psi_{\text{dyn}}(\Delta t,\ \mathbf{x}) \;+\; \sum_{i} \Psi_{\text{weak}}\!\bigl(g_i,\ \hat g,\ \bar{\kappa}_i\bigr), \tag{3} \] with respect to
        \(\mathbf{x}\) encoding mesh vertices, where \(\Psi_{\text{dyn}}\) encodes step-size \(\Delta t\) dependent inertia and elastic energies [Martin et al. 2011] (e.g., hyper-elasticity and
        bending). \(\Psi_{\text{weak}}\) encodes contacts, boundary conditions, and strain limiting. Once again, \(\bar{\kappa}\) is semi-implicitly updated when computing the derivatives of
        respective types at every Newton’s step. This also means that the objective function itself changes slightly at each Newton step.
      </p>
    </div>
    <!-- ============== 3.2 Time Integration ============== -->
    <div class="trans">
      <h3>3.2 时间积分（Time Integration）</h3>
      <p>
        理想情况下，我们希望在式 (3) 的目标函数梯度几乎达到数值精度零点的解处终止。 但即使完全隐式求解，这通常也需要大量迭代。因此，我们采用文中“算法 1”所示的
        <strong>定制牛顿法</strong>来最小化式 (3)。 其中 \(0<\alpha\le1\) 是<strong>直线搜索</strong>的分数系数，表示在考虑接触（更形式地说，约束）后的最大可行步长。 记 \(\nabla_{\mathbf{x}}^2\) 与
        \(\nabla_{\mathbf{x}}\) 分别为关于 \(\mathbf{x}\) 的二阶与一阶导数。 虽然该算法并不追求准确的收敛解，但我们发现它能在无不稳定性的前提下得到
        视觉上令人满意的结果。简要小结如下（细节见补充材料）。
      </p>

      <h4>3.2.1 我们的时间积分器概览</h4>
      <p>
        关键思想：最优位置是步长 \(\Delta t\) 的函数。显然，当 \(\Delta t=0\) 时最优位置不移动； 当 \(\Delta t\) 足够小时，位置轨迹在一步内近似线性。 由此可作如下假设：若把搜索方向按直线搜索因子
        \(\alpha\) 缩小， 则该解可解释为时刻 \(\alpha\Delta t\) 的解。然而，一旦包含多次牛顿迭代， 第一轮之后的缩放难以再作同样解释。
      </p>
      <p>
        为使策略适用于多次牛顿步，我们考虑一个仅受惯性、以<strong>恒速</strong>运动的虚拟粒子。 在此情形下，惯性能量为 \(m_p\lVert \mathbf{x}-\mathbf{z}\rVert^2/2\)， 其中 \(\mathbf{z}\) 是时刻
        \(t+\Delta t\) 的目标惯性位置，\(m_p\) 为粒子质量。 若第一次前进 \(\alpha_1(\mathbf{z}-\mathbf{x})\)，则余下路径为 \((1-\alpha_1)(\mathbf{z}-\mathbf{x})\)。 下一牛顿步若再以 \(\alpha_2\)
        缩小位移，则粒子移动 \(\alpha_2(1-\alpha_1)(\mathbf{z}-\mathbf{x})\)。 推广可得算法 1 第 3 行的累计更新律 \(\beta \leftarrow \beta+(1-\beta)\alpha\)，我们将累计步长记为 \(\beta\)。
      </p>

      <h4>3.2.2 目标最大 \(\beta_{\max}\)</h4>
      <p>
        我们的积分器表明，除非直线搜索报告“无碰撞”，否则很难达到 \(\beta=1\)。 在高接触密度场景中该判断代价很高。为此我们设定最大累计步长 \(\beta_{\max}\)。所有示例中均取 \(\beta_{\max}=1/4\)。
        我们所有步骤（含接触摩擦情形，显式限定 32 次牛顿步）都满足该退出条件。 更大的数值（如 \(1/2\)）也可行，但我们发现 \(1/4\) 在精度与性能之间更均衡。
      </p>

      <h4>3.2.3 误差消减（Error Reduction）</h4>
      <p>
        上述推导只考虑了惯性；实际仿真还包括重力与弹力，因此在 \(\Delta t\) 内轨迹并非严格线性。 但当 \(\Delta t\) 足够小时，惯性项 \(m_p/\Delta t^2\) 占主导，上述预测仍是良好近似。
        因此，在退出优化环之前，我们用 \(\beta\Delta t\) 重新配置目标函数， 并额外执行一次牛顿步以<strong>消减误差</strong>。
      </p>

      <h4>3.2.4 扩展搜索方向</h4>
      <p>
        用搜索方向更新顶点位置时，我们谨慎避免顶点落在过于接近约束边界处， 否则下一牛顿步的刚度可能过大，引发不稳定。我们将搜索方向
        <strong>延长 25%</strong>，并进行从 \(\mathbf{x}\) 到 \(\mathbf{x}+1.25\,\mathbf{d}\) 的约束直线搜索， 选取最大可行的 \(\alpha\)。我们只对约束做直线搜索，未观察到不稳定性（细节见补充材料）。
      </p>

      <h5>算法 1　仿真一步（Simulation Step）</h5>
      <pre class="algo">
function ADVANCE_STEP(Δt, x)
  β ← 0
  while β &lt; β_max do                ▷ Newton’s Step
    x, α ← INNER_STEP(Δt, x)
    β ← β + (1 − β) α
  end while
  x, _ ← INNER_STEP(β Δt, x)         ▷ Error Reduction Pass
  return x, β Δt                     ▷ Actual Advanced Step
end function

function INNER_STEP(Δt, x)
  H, f ← ∇_x^2 Ψ_total , −∇_x Ψ_total   ▷ 在评估中应用 \bar{κ} 的更新
  d ← H^{-1} f
  α ← Constraint Line Search from x to x + 1.25 d
  return x + α d , α
end function
  </pre
      >
    </div>

    <div class="ori">
      <h3>3.2 Time Integration</h3>
      <p>
        Ideally, we seek the point of (3) where the gradient of the objective vanishes to near numerical precision. However, this requires many iterations, even if we could solve it fully implicitly.
        Therefore, we minimize (3) via a customized Newton’s method as illustrated in Algorithm 1. \(0&lt;\alpha\le1\) is a line-search fractional coefficient encoding the maximal contact-aware
        (constraint-aware) feasible step size. Operators \(\nabla_{\mathbf{x}}^2\) and \(\nabla_{\mathbf{x}}\) are second and first derivatives w.r.t. \(\mathbf{x}\). Although this algorithm does not
        achieve accurate converged solutions, it still produces visually satisfactory results without instabilities. A summary is provided below; details are in the supplementary material.
      </p>

      <h4>3.2.1 Our Temporal Integrator Overview</h4>
      <p>
        The key idea is that the optimized position is a function of the step size \(\Delta t\). When \(\Delta t=0\), the optimized position clearly does not move. Also, when \(\Delta t\) is
        sufficiently small, the positional trajectory is nearly linear within the step. From these, we assume that when the search direction is reduced by a line-search factor \(\alpha\), this
        solution can be interpreted as a solution at time \(\alpha\Delta t\). However, this analogy does not apply when multiple Newton steps are involved, as it becomes unclear how to interpret
        line-search scaling factors after the first step.
      </p>
      <p>
        To make our strategy applicable for multiple Newton steps, we consider a virtual particle in purely inertial motion, moving with a constant velocity. In this case, the inertial potential
        energy is \(m_p\lVert \mathbf{x}-\mathbf{z}\rVert^2/2\), where \(\mathbf{z}\) is a target inertia position at \(t+\Delta t\) and \(m_p\) is the particle mass. When the particle advances by
        \(\alpha_1(\mathbf{z}-\mathbf{x})\) for the first time, the remaining path is \((1-\alpha_1)(\mathbf{z}-\mathbf{x})\). In the next Newton step, when the displacement is shrunk by \(\alpha_2\),
        the particle moves by \(\alpha_2(1-\alpha_1)(\mathbf{z}-\mathbf{x})\). We generalize this idea to predict the accumulated step sizes and arrive at the update rule in Line 3 of Algorithm 1. The
        accumulated step size is recorded as \(\beta\).
      </p>

      <h4>3.2.2 Target Maximal \(\beta_{\max}\)</h4>
      <p>
        Our time integrator indicates that reaching exactly \(\beta=1\) is not possible unless the line search reports no collision, which is very expensive in contact-rich scenarios. To address this,
        we set a maximum value for \(\beta\), denoted as \(\beta_{\max}\). For all examples, we set \(\beta_{\max}=1/4\). All the steps in our examples have met this criterion to exit the loop,
        including contact frictional cases, which were explicitly enforced to take 32 Newton steps. A larger value, such as \(\beta_{\max}=1/2\), is possible; however, \(\beta_{\max}=1/4\) provides a
        better balance between accuracy and performance.
      </p>

      <h4>3.2.3 Error Reduction Pass</h4>
      <p>
        In the above, we only assumed inertial motion; however, the actual simulation also involves gravity and elasticity forces. Therefore, the trajectory is nonlinear within \(\Delta t\).
        Nevertheless, for small \(\Delta t\), the inertia term \(m_p/\Delta t^2\) becomes dominant, so the above prediction serves as a good approximation. For this reason, before exiting the
        optimization loop, we reconfigure the objective with \(\beta\Delta t\) and run an additional error-reduction Newton’s step.
      </p>

      <h4>3.2.4 Extended Search Direction</h4>
      <p>
        When updating vertex positions with the search direction, we ensure that vertices do not settle too close to constraint limits; otherwise, the stiffness may become too large in the next Newton
        step, leading to instability. We extend the search direction by 25%, and obtain the line-search scaling factor \(\alpha\) that encodes the maximal feasible displacement from \(\mathbf{x}\) to
        \(\mathbf{x}+1.25\,\mathbf{d}\). We performed constraint-only line searches and did not observe any instabilities. More details are provided in the supplementary material.
      </p>

      <h5>Algorithm 1 Simulation Step</h5>
      <pre class="algo_rev">
function ADVANCE_STEP(Δt, x)
  β ← 0
  while β &lt; β_max do
    x, α ← INNER_STEP(Δt, x)         ▷ Newton’s Step
    β ← β + (1 − β) α
  end while
  x, _ ← INNER_STEP(β Δt, x)         ▷ Error Reduction Pass
  return x, β Δt                     ▷ Actual Advanced Step
end function

function INNER_STEP(Δt, x)
  H, f ← ∇_x^2 Ψ_total , −∇_x Ψ_total   ▷ \bar{κ} updates applied during evaluation.
  d ← H^{-1} f
  α ← Constraint Line Search from x to x + 1.25 d
  return x + α d , α
end function
  </pre
      >
    </div>
    <!-- ============== 3.3 Our Stiffness Design Principle ============== -->
    <div class="trans">
      <h3>3.3 我们的刚度设计原则（Our Stiffness Design Principle）</h3>
      <p>
        经验上，\(\Delta t\) 与 \(\hat g\) 常满足 \(\hat g/\Delta t \approx 1\,\mathrm{m/s}\)。 从数值角度看（两者均为 SI 制单位），这意味着它们量级通常相近。 惯性 Hessian 的特征值为 \(m/\Delta
        t^2\)（\(m\) 为元素质量），我们希望接触 Hessian 的特征值也在这个量级， 以使接触处理对条件数的影响可控。注意到我们的三次障碍 \(\Psi_{\text{weak}}\) 的二阶导（曲率） 在 \(g\to0\) 时线性逼近
        \(2\kappa\)。令 \(\kappa = m/g^2\) 即可把接触对条件数的影响控制在与惯性项同一量级。
      </p>

      <h4>3.3.1 含弹性的刚度（Elasticity-Inclusive Stiffness）</h4>
      <p>
        由上，惯性“刚度”（其 Hessian 的特征值）为 \(m/\Delta t^2\)。进一步考虑弹性能量： 设 \(\mathbf{H}\) 为弹性 Hessian，\(\mathbf{n}\) 为关注方向（如接触法线）的单位向量， 则系统在 \(\mathbf{n}\)
        方向的总“刚度”为 \(m/\Delta t^2 + \mathbf{n}\cdot(\mathbf{H}\mathbf{n})\)。 于是我们把障碍的半隐式刚度 \(\bar{\kappa}\) 设为
      </p>
      <p>\[ \boxed{\;\bar{\kappa} \;=\; \dfrac{m}{g^{2}} \;+\; \mathbf{n}\cdot(\mathbf{H}\mathbf{n})\;}\tag{4} \]</p>
      <p>
        如此，障碍在理想情况下足够刚以抵抗来向的作用力；若仍不足，\(\tfrac{m}{g^2}\) 项会在 \(g\to0\) 时自动增强，从而抵消外力。连续碰撞检测（或更一般的直线搜索机制）可防止约束穿透。
        这就确立了我们的设计原则：对每一种约束类型，定义相应的质量 \(m\)、几何间隙 \(g\)、方向 \(\mathbf{n}\) 与弹性 Hessian \(\mathbf{H}\)，并将它们代入式 (4)。后文所有 \(\bar{\kappa}\)
        均遵循该规则。
      </p>
    </div>

    <div class="ori">
      <h3>3.3 Our Stiffness Design Principle</h3>
      <p>
        We begin by observing that the step size \(\Delta t\) and \(\hat g\) often satisfy, e.g., \(\hat g/\Delta t \approx 1\,\mathrm{m/s}\). In SI units, this implies that their magnitudes are
        typically of the same order. Recalling that the stiffness (eigenvalue of the inertia Hessian) is \(m/\Delta t^{2}\), we aim for the eigenvalue of the contact Hessian to be of the same order so
        that the conditioning pollution due to contact handling remains predictable. The second derivative (curvature) of our cubic barrier \(\Psi_{\text{weak}}\) linearly approaches \(2\kappa\) as
        \(g\to0\). By setting \(\kappa=m/g^{2}\), we control the impact to be around the same order as the inertia term.
      </p>

      <h4>3.3.1 Elasticity-Inclusive Stiffness</h4>
      <p>
        From the above, the stiffness (the eigenvalue of its Hessian) of the inertia is \(m/\Delta t^{2}\). This can be extended to account for elasticity energy: let \(\mathbf{H}\) represent the
        elasticity Hessian and \(\mathbf{n}\) be a unit vector of interest (e.g., the contact normal). In this context, the total system stiffness in the direction of \(\mathbf{n}\) is \(m/\Delta
        t^{2} + \mathbf{n}\cdot(\mathbf{H}\mathbf{n})\). The idea is to assign the barrier stiffness in the form
      </p>
      <p>\[ \boxed{\;\bar{\kappa} \;=\; \dfrac{m}{g^{2}} \;+\; \mathbf{n}\cdot(\mathbf{H}\mathbf{n})\;}\tag{4} \]</p>
      <p>
        Ideally, the barrier would be stiff enough to resist incoming forces. If still weak, the \(m/g^{2}\) term ensures the barrier becomes strong enough as \(g\to0\) to counteract forces.
        Continuous collision detection—or more generally, the line-search mechanism—prevents constraint pass-through. This establishes our stiffness design principle: for each constraint type, we
        define the corresponding mass \(m\), geometric gap \(g\), direction \(\mathbf{n}\), and elasticity Hessian \(\mathbf{H}\), and substitute them into (4). All subsequent \(\bar{\kappa}\) adhere
        to this rule.
      </p>
    </div>
    <!-- ================= 3.4 Contact Stiffness ================= -->
    <div class="trans">
      <h3>3.4 接触刚度（Contact Stiffness）</h3>
      <p>
        基于前述原则，我们先给出接触的刚度定义。接触能量写作 \(\Psi_{\text{contact}}=\Psi_{\text{weak}}\!\bigl(g_i,\ \hat g,\ \bar\kappa^{\text{contact}}_i\bigr)\)。 在接触邻近性查询需要计算接触
        Hessian 或力时，我们更新该接触刚度。
      </p>
      <p>
        刚度取为 \[ \boxed{\;\bar\kappa^{\text{contact}}_i \;=\; \frac{m_i}{g_i^{2}} \;+\; \frac{\mathbf{w}_i}{\lVert \mathbf{w}_i\rVert}\cdot \!\left(\,H\,\frac{\mathbf{w}_i}{\lVert
        \mathbf{w}_i\rVert}\right)\;} \tag{5} \] 其中 \(m_i\) 为（与接触相关的）平均顶点质量； \(\mathbf{w}_i\) 为扩展的接触方向。其计算方式为：令 \(\mathbf{p}_i,\mathbf{q}_i\)
        表示一对几乎接触的位置， 存在矩阵 \(W_i\) 使得 \(\mathbf{p}_i-\mathbf{q}_i=W_i\,\mathbf{x}\)，则 \(\mathbf{w}_i=W_i^{\!\top}(\mathbf{p}_i-\mathbf{q}_i)\)。 \(H\) 是对称（半）正定化后的弹性
        Hessian。
      </p>
      <p>
        这里 \(W_i^{\!\top}\) 的作用是用合适的权重把接触方向 \(\mathbf{p}_i-\mathbf{q}_i\) 重新分配到构成接触的顶点上。 例如，当 \(W\) 是两点插值算子且权重为 \((\tfrac12,\tfrac12)\)
        时，其转置会把插值量平均回分配给两点； 若权重为 \((1,0)\)，则“重分配”仅把数值返回给第一个点。之所以需要这样做，是因为 \(H\) 作为关于顶点自由度的线性算子起作用。
      </p>
      <p>
        注意我们在（5）式右端<strong>评估后即固定</strong>这些项，因此求导时不再应用链式法则， 也就<strong>无需</strong>到达 \(H\) 的六阶张量。接触相关导数使用半隐式线性化
        （Chen&nbsp;et&nbsp;al.,&nbsp;2024），细节见补充材料。
      </p>
    </div>

    <div class="ori">
      <h3>3.4 Contact Stiffness</h3>
      <p>
        With the knowledge above, we start by defining the stiffness for contact. The contact energy is given by \(\Psi_{\text{contact}}=\Psi_{\text{weak}}(g_i,\hat g,\bar\kappa^{\text{contact}}_i)\).
        We update the contact stiffness when it is requested by the computation of contact Hessians and forces during the contact proximity query. The stiffness \(\bar\kappa^{\text{contact}}_i\) is
        given by
      </p>
      <p>
        \[ \bar\kappa^{\text{contact}}_i \;=\; \frac{m_i}{g_i^{2}} \;+\; \frac{\mathbf{w}_i}{\lVert \mathbf{w}_i\rVert}\cdot \!\left(\,H\,\frac{\mathbf{w}_i}{\lVert \mathbf{w}_i\rVert}\right), \tag{5}
        \] where \(m_i\) is an average vertex mass. \(\mathbf{w}_i\) is an extended contact direction computed as follows: let \(\mathbf{p}_i\) and \(\mathbf{q}_i\) denote two nearly touching
        positions forming a contact, and \(W_i\) be a matrix such that \(\mathbf{p}_i-\mathbf{q}_i=W_i\,\mathbf{x}\). Then \(\mathbf{w}_i=W_i^{\!\top}(\mathbf{p}_i-\mathbf{q}_i)\). \(H\) is the
        elasticity Hessian after being enforced symmetric (semi-)positive definite.
      </p>
      <p>
        The purpose of \(W_i^{\!\top}\) is to redistribute the contact direction \(\mathbf{p}_i-\mathbf{q}_i\) to the vertices forming the contact, using appropriate weighting. For example, if \(W\)
        is an interpolation operator for two particles with equal weights \((\tfrac12,\tfrac12)\), its transpose distributes the interpolated value back to both particles equally. If the weights are
        \((1,0)\), the redistribution operator simply returns the value back to the first particle. This is necessary because \(H\) is the linear operator with respect to the vertices.
      </p>
      <p>
        Recalling that we fix all the terms on the right-hand side of (5) after evaluation, the chain rule does not apply when taking derivatives. Therefore, 6th-order tensors of \(H\) are not
        necessary. We compute contact derivatives using a semi-implicit linearization (Chen et al., 2024), which we detail in the supplementary material.
      </p>
    </div>

    <!-- ================= 3.5 Boundary Conditions ================= -->
    <div class="trans">
      <h3>3.5 边界条件（Boundary Conditions）</h3>
      <p>
        设我们希望将顶点 \(\mathbf{x}_i\) 钉扎到固定位置 \(\mathbf{p}^{\text{fixed}}\)。 能量写作 \(\Psi_{\text{pin}}=\tfrac12\,\bar\kappa^{\text{pin}}_i\,\lVert
        \mathbf{x}_i-\mathbf{p}^{\text{fixed}}\rVert^2\)， 其中 \(\bar\kappa^{\text{pin}}_i\) 为钉扎刚度。 此时几何“间隙”定义为 \(\hat g^{\text{pin}}_i-\lVert
        \mathbf{x}_i-\mathbf{p}^{\text{fixed}}\rVert\)， 将其代入刚度规则得到
      </p>
      <p>
        \[ \boxed{\;\bar\kappa^{\text{pin}}_i \;=\; \frac{m_i}{\bigl(\hat g^{\text{pin}}_i-\lVert \mathbf{x}_i-\mathbf{p}^{\text{fixed}}\rVert\bigr)^2} \;+\; \frac{\mathbf{w}_i}{\lVert
        \mathbf{w}_i\rVert}\cdot \!\left(\,H_{ii}\,\frac{\mathbf{w}_i}{\lVert \mathbf{w}_i\rVert}\right)\;} \tag{6} \] 其中 \(\mathbf{w}_i=\mathbf{x}_i-\mathbf{p}^{\text{fixed}}\)，\(m_i\) 为第 \(i\)
        个顶点质量， \(H_{ii}\) 是从 \(H\) 取出的与顶点 \(i\) 对应的 \(3\times3\) 子块。在需要其 Hessian/力时更新该钉扎刚度。
      </p>
      <p>
        类似地，若希望把顶点 \(\mathbf{x}_i\) 推离墙面，我们沿用相同的接触能量，只是刚度改为 \[ \boxed{\;\bar\kappa^{\text{wall}}_i \;=\; \frac{m_i}{\bigl(g^{\text{wall}}_i\bigr)^2} \;+\;
        \mathbf{n}_{\text{wall}}\!\cdot\!\bigl(H_{ii}\,\mathbf{n}_{\text{wall}}\bigr)\;} \tag{7} \] 其中 \(\mathbf{n}_{\text{wall}}\) 为墙面法线，\(g^{\text{wall}}_i\) 是墙面边界条件使用的间隙容差。
      </p>
    </div>

    <div class="ori">
      <h3>3.5 Boundary Conditions</h3>
      <p>
        We wish to pin vertex \(\mathbf{x}_i\) to a fixed position \(\mathbf{p}^{\text{fixed}}\). The energy is \(\Psi_{\text{pin}}=\tfrac12\,\bar\kappa^{\text{pin}}_i\,\lVert
        \mathbf{x}_i-\mathbf{p}^{\text{fixed}}\rVert^2\), where \(\bar\kappa^{\text{pin}}_i\) is a pin stiffness. In this case, the geometrical gap is \(\hat g^{\text{pin}}_i-\lVert
        \mathbf{x}_i-\mathbf{p}^{\text{fixed}}\rVert\). Hence, we define
      </p>
      <p>
        \[ \bar\kappa^{\text{pin}}_i \;=\; \frac{m_i}{\bigl(\hat g^{\text{pin}}_i-\lVert \mathbf{x}_i-\mathbf{p}^{\text{fixed}}\rVert\bigr)^2} \;+\; \frac{\mathbf{w}_i}{\lVert \mathbf{w}_i\rVert}\cdot
        \!\left(\,H_{ii}\,\frac{\mathbf{w}_i}{\lVert \mathbf{w}_i\rVert}\right), \tag{6} \] where \(\mathbf{w}_i=\mathbf{x}_i-\mathbf{p}^{\text{fixed}}\), \(m_i\) is the mass of the \(i\)-th vertex,
        and \(H_{ii}\) is a \(3\times3\) matrix (the \(i\)-th vertex block) selected from \(H\). We update the pin stiffness when requested during computing its Hessian and forces. Similarly, to push
        vertex \(\mathbf{x}_i\) out of walls, we use the same contact energy but set the stiffness to
      </p>
      <p>
        \[ \bar\kappa^{\text{wall}}_i \;=\; \frac{m_i}{\bigl(g^{\text{wall}}_i\bigr)^2} \;+\; \mathbf{n}_{\text{wall}}\!\cdot\!\bigl(H_{ii}\,\mathbf{n}_{\text{wall}}\bigr), \tag{7} \] where
        \(\mathbf{n}_{\text{wall}}\) is the wall normal and \(g^{\text{wall}}_i\) is a gap tolerance for wall boundary conditions.
      </p>
    </div>

    <!-- ================= 3.6 Strain Limiting ================= -->
    <div class="trans">
      <h3>3.6 应变限制（Strain Limiting）</h3>
      <p>
        每个三角形的应变限制能量定义为 \[ \Psi_{\text{SL}}(\sigma_1,\sigma_2) \;=\; \Psi_{\text{SL1}}(\sigma_1)+\Psi_{\text{SL1}}(\sigma_2), \tag{8a} \] \[ \Psi_{\text{SL1}}(\sigma) \;=\;
        \Psi_{\text{weak}}\!\bigl(1+\tau+\hat\varepsilon-\sigma,\ \hat\varepsilon,\ \bar\kappa_{\text{SL}}\bigr). \tag{8b} \] 其中 \(\sigma_j=\sigma_j(\mathbf{x})\) 为形变梯度 \(F\)（在变形位置
        \(\mathbf{x}\) 处）的奇异值， \(\tau,\hat\varepsilon\) 为小常数。所有示例中取 \(\tau=\hat\varepsilon\)。 若令 \(\tau+\hat\varepsilon=0.05\)，则把拉伸严格限制在 5% 以内。
        \(\tau+\hat\varepsilon\) 也见 CIPC（Li&nbsp;et&nbsp;al.,&nbsp;2021）。
      </p>
      <p>
        我们的应变限制刚度依赖于奇异值，因此先更新奇异值， 再在需要计算应变限制的 Hessian 与力之前立即更新刚度。 应变限制的几何“间隙”为 \(1+\tau+\hat\varepsilon-\max(\sigma_1,\sigma_2)\)。 刚度取为 \[
        \boxed{\;\bar\kappa_{\text{SL}} \;=\; \frac{m_{\text{face}}}{\bigl(1+\tau+\hat\varepsilon-\max(\sigma_1,\sigma_2)\bigr)^2} \;+\; \mathbf{w}_r\!\cdot\!\bigl(H_{9\times9}\,\mathbf{w}_r\bigr)\;}
        \tag{9} \] 其中：取某三角形的三个顶点 \(\mathbf{x}_{1\ldots3}\)，设 \(\mathbf{r}_j=\mathbf{x}_j-\frac{\mathbf{x}_1+\mathbf{x}_2+\mathbf{x}_3}{3}\)， \(\mathbf{w}_r=[\,\mathbf{r}_1^{\!\top}\
        \mathbf{r}_2^{\!\top}\ \mathbf{r}_3^{\!\top}\,]^{\!\top}\)； \(H_{9\times9}\) 为由 \(H_{jk}\)（顶点对 \(j,k\) 的 \(3\times3\) 子块，含 \(j=k\) 的对角块）组成的分块矩阵，
        度量该三角形在切向平面上的等效刚度；\(m_{\text{face}}\) 为该三角形质量。 这里不对 \(\mathbf{w}_r\) 归一化，以与奇异值的标度保持一致。
      </p>
      <p>
        更具体地说，奇异值与网格尺寸无关，刻画相对拉伸。 因此（9）式第一项的分母本应由某个“代表性的网格长度”的平方来归一化（因为间隙被平方）； 我们选择 \(\lVert \mathbf{w}_r\rVert\) 作为代表长度。
        若把约束方向归一化为 \(\mathbf{w}_r/\lVert \mathbf{w}_r\rVert\)， 则第二项将变为 \(\frac{1}{\lVert \mathbf{w}_r\rVert^{2}}(\mathbf{w}_r\!\cdot\!H_{9\times9}\mathbf{w}_r)\)。 通过以 \(\lVert
        \mathbf{w}_r\rVert^{2}\) 重标度即可消去该分母，从而保留 \(\mathbf{w}_r\!\cdot\!H_{9\times9}\mathbf{w}_r\) 这一简单形式。
      </p>
      <p>
        需要指出的是，有了应变限制后，系统刚度会显著<strong>硬于</strong>接触情形， 因为高分辨率网格中三角形的微小变化会引起总能量的突变。 但经验上，我们的 \(3\times3\) 分块 Jacobi
        预条件器足够稳健以应对这些挑战。
      </p>
      <p>
        将（8a）嵌入式（3）时，需要对形变梯度求一、二阶导。 既有工作多依赖不变量（Chen&nbsp;and&nbsp;Weber&nbsp;2017; Kim&nbsp;and&nbsp;Eberle&nbsp;2022; Panetta&nbsp;2020），
        但要把任意各向同性能量写成（8a）那样基于奇异值的形式并不总是直接的（例如 \(k(\sigma_k-1)^3\)、\(-\sum_k\log\sigma_k\)）。 可按 Li&nbsp;et&nbsp;al.&nbsp;(2022)
        的做法实现，但仍需解隐式方程；其他方法（Stomakhin&nbsp;et&nbsp;al.&nbsp;2012; Xu&nbsp;et&nbsp;al.&nbsp;2015） 在 \(\sigma_1=\sigma_2\)
        时存在退化。为此，我们在补充材料中给出了显式特征分解方案。
      </p>
    </div>

    <div class="ori">
      <h3>3.6 Strain Limiting</h3>
      <p>
        Energy for strain limiting per triangle is given by \[ \Psi_{\text{SL}}(\sigma_1,\sigma_2)=\Psi_{\text{SL1}}(\sigma_1)+\Psi_{\text{SL1}}(\sigma_2), \tag{8a} \] \[
        \Psi_{\text{SL1}}(\sigma)=\Psi_{\text{weak}}(1+\tau+\hat\varepsilon-\sigma,\ \hat\varepsilon,\ \bar\kappa_{\text{SL}}), \tag{8b} \] where \(\sigma_j\) is a function of \(\mathbf{x}\),
        representing the singular values of a deformation gradient \(F\) at the deformed state \(\mathbf{x}\). \(\tau\) and \(\hat\varepsilon\) are small constants; we set \(\tau=\hat\varepsilon\) in
        all examples. If \(\tau+\hat\varepsilon=0.05\), strain is strictly enforced within 5% of stretch. \(\tau+\hat\varepsilon\) is also found in CIPC (Li et al., 2021).
      </p>
      <p>
        The stiffness for strain limiting depends on the singular values. Therefore, we first update the singular values, and then update the stiffness just before it is requested for computing strain
        limiting Hessians and forces. The geometrical gap is \(1+\tau+\hat\varepsilon-\max(\sigma_1,\sigma_2)\). Therefore, we define \[ \bar\kappa_{\text{SL}} \;=\;
        \frac{m_{\text{face}}}{\bigl(1+\tau+\hat\varepsilon-\max(\sigma_1,\sigma_2)\bigr)^2} \;+\; \mathbf{w}_r\!\cdot\!\bigl(H_{9\times9}\,\mathbf{w}_r\bigr), \tag{9} \] where
        \(\mathbf{x}_{1\ldots3}\) are the triangle vertices, \(\mathbf{r}_j=\mathbf{x}_j-(\mathbf{x}_1+\mathbf{x}_2+\mathbf{x}_3)/3\), and \(\mathbf{w}_r=[\,\mathbf{r}_1^{\!\top}\
        \mathbf{r}_2^{\!\top}\ \mathbf{r}_3^{\!\top}\,]^{\!\top}\). \(H_{9\times9}\) is a block matrix where each sub \(3\times3\) matrix is extracted from \(H_{jk}\) for a vertex pair \(j,k\) chosen
        from the three vertices, including duplicates \(j=k\). This encodes the stiffness of the triangle, and the action of \(\mathbf{w}_r\) measures the stiffness in the tangential plane.
        \(m_{\text{face}}\) is the triangle mass. Note that \(\mathbf{w}_r\) is not normalized for scaling consistency with singular values.
      </p>
      <p>
        More specifically, singular values are independent of the mesh size and encode the relative stretch from the rest pose. Therefore, the denominator in the first term would have been scaled by a
        squared representative mesh length, because the gap is squared there. We choose \(\lVert \mathbf{w}_r\rVert\) as the representative length. The normalized constraint direction is
        \(\mathbf{w}_r/\lVert \mathbf{w}_r\rVert\), so the second term would have been \(\tfrac{1}{\lVert \mathbf{w}_r\rVert^{2}}(\mathbf{w}_r\!\cdot\!H_{9\times9}\mathbf{w}_r)\). Rescaling by
        \(\lVert \mathbf{w}_r\rVert^{2}\) removes the denominator, leaving simply \(\mathbf{w}_r\!\cdot\!(H_{9\times9}\mathbf{w}_r)\).
      </p>
      <p>
        It should be noted that when strain limiting exists the system stiffness becomes much stiffer than contacts, because small variation in the triangular mesh results in abrupt changes in the
        total energy for high resolution meshes. Nevertheless, we empirically find that the \(3\times3\) block Jacobi preconditioner was robust enough to handle such challenges in our examples.
      </p>
      <p>
        When embedding (8a) into (3), we need to compute first and second derivatives of (8a) with respect to a deformation gradient. Previous literature depends on invariants (Chen and Weber 2017;
        Kim and Eberle 2022; Panetta 2020), but it is not clear how to express arbitrary isotropic energies using invariants in the form of (8a), such as \(k(\sigma_k-1)^3\) and
        \(-\sum_k\log\sigma_k\). One could realize it as shown by Li et al. (2022) but still needs to solve implicit equations. Other methods (Stomakhin et al. 2012; Xu et al. 2015) contain a
        degenerate case \(\sigma_1=\sigma_2\). To the best of our knowledge, explicit expressions remain unclear. To this end, we provide an explicit eigensystem in the supplementary material.
      </p>
    </div>
    <!-- ================= 3.7 Matrix Assembly ================= -->
    <div class="trans">
      <h3>3.7 矩阵组装（Matrix Assembly）</h3>
      <p>
        我们的矩阵组装基于 CAMA [Tang et&nbsp;al.&nbsp;2016]，此处只给出与其不同之处。我们选择
        <strong>显式组装</strong>而非“matrix-free”方法——尽管名字如此，显式组装在内存上更高效。 具体理由见补充材料；实现细节也在补充材料中提供。
      </p>
      <p>
        在 CAMA 中最耗内存的是“填充（fill-in）”阶段：在压缩前会出现条目重复。我们通过
        <strong>重用上一步的接触对</strong>来降低开销，将其用作缓存索引表。组装接触矩阵时，先查缓存；若命中， 则原子地把当前值合并到该缓存对应的条目中。这样可获得<strong>数量级</strong>的内存节省。
      </p>
      <p>
        为进一步提升效率，我们维护了三套类似“缓存分层”的矩阵：<strong>3×3 对角分块</strong>、基于网格连通性的
        <strong>固定索引表矩阵</strong>，以及<strong>接触矩阵</strong>。当增量插入一个矩阵条目时，优先尝试前者，未命中再 退到后者。
      </p>
    </div>

    <div class="ori">
      <h3>3.7 Matrix Assembly</h3>
      <p>
        Our matrix assembly is based on CAMA [Tang et al. 2016], and as such we only present differences. We chose explicit matrix assembly over matrix-free methods because, despite its name, explicit
        assembly is more memory efficient. Interested readers are referred to our supplementary material for this reasoning. Implementation details are also available in the supplementary material.
      </p>
      <p>
        The most memory consuming part in CAMA is the fill-in pass of matrix entries, which involves entry duplicates before being compressed. We minimize this by re-using contact pairs from the
        previous step, and use them as a cached index table. When assembling the contact matrix, we look for the cache first and if it exits, we atomically merge to the value associated with the
        cache. The result is an order of magnitude efficient memory saving.
      </p>
      <p>
        For more efficiency, we have three sets of matrices resembling a cache hierarchy; 3×3 block diagonal, index-table fixed based on the mesh connectivity, and the contact matrices. When
        incrementally adding a matrix entry, we try former first and move on to the later ones if missed.
      </p>
    </div>
    <!-- ================= 3.8 Frictional Contacts ================= -->
    <div class="trans">
      <h3>3.8 含摩擦的接触（Frictional Contacts）</h3>
      <p>摩擦并非本文的贡献点，但对实际接触仿真很重要。为此我们采用如下<strong>二次型势能</strong>：</p>
      <p>
        \[ \Psi_{\text{friction}} \;=\; \tfrac12\,\bar{\kappa}^{\text{friction}}_{i}\,\bigl\lVert P_i\,W_i\,(\mathbf{x}-\mathbf{x}^{\text{prev}})\bigr\rVert^{2}, \tag{10} \] \[
        \bar{\kappa}^{\text{friction}}_{i} \;=\; \frac{\mu\,f^{\text{contact}}_{i}} {\max\!\Bigl(\,\varepsilon,\ \bigl\lVert P_i\,W_i\,(\mathbf{x}-\mathbf{x}^{\text{prev}})\bigr\rVert\,\Bigr)}.
        \tag{11} \] 其中 \(P_i=I-\mathbf{n}_i\mathbf{n}_i^{\!\top}\) 为投影算子（\(\mathbf{n}_i\) 是接触法线）， \(\mathbf{x}^{\text{prev}}\) 为上一步网格顶点；\(\mu\) 与 \(f^{\text{contact}}_{i}\)
        分别为摩擦系数与接触力。 \(\varepsilon\) 为小常数，这里取 \(\varepsilon=0.01\,\text{mm}\)（首个牛顿步有 \(\mathbf{x}=\mathbf{x}^{\text{prev}}\)）。 \(f^{\text{contact}}_{i}\)
        来自将接触障碍并入系统矩阵时的项，是障碍势的一阶导。 注意势能不应再按质量或面积缩放，因为 \(f^{\text{contact}}_{i}\) 已经隐含了这些因素。
      </p>
      <p>
        由于 \(\bar{\kappa}^{\text{friction}}_{i}\) 依赖接触力，我们在<strong>计算出接触力后</strong>更新该刚度，并用其计算 Hessian 与力。读者会注意到，首个牛顿步时 Hessian 的特征值将变为
        \(\mu\,f^{\text{contact}}_{i}/\varepsilon\)， 可能非常大；如需处理，可在计算摩擦势的 Hessian 时，用接触障碍的最大曲率 \(\partial^{2}\Psi_{\text{weak}}/\partial g_i^{2}\) 对
        \(\bar{\kappa}^{\text{friction}}_{i}\) <strong>加上截断上限</strong>， 同时保持力项不变。我们将展示，要使动画与指定摩擦系数 \(\mu\) 匹配，通常需要<strong>足够多</strong>的牛顿步（建议 32
        步）。
      </p>
    </div>

    <div class="ori">
      <h3>3.8 Frictional Contacts</h3>
      <p>Friction is not our contribution, but it is important for practical contact simulations. For this purpose, we use the following quadratic potential</p>
      <p>
        \[ \Psi_{\text{friction}} = \tfrac12\,\bar{\kappa}^{\text{friction}}_{i}\,\lVert P_i\,W_i\,(\mathbf{x}-\mathbf{x}^{\text{prev}})\rVert^{2}, \tag{10} \] \[ \bar{\kappa}^{\text{friction}}_{i} =
        \frac{\mu\,f^{\text{contact}}_{i}} {\max\!\bigl(\varepsilon,\ \lVert P_i\,W_i\,(\mathbf{x}-\mathbf{x}^{\text{prev}})\rVert\bigr)}. \tag{11} \]
      </p>
      <p>
        where \(P_i = I-\mathbf{n}_i\mathbf{n}_i^{\!\top}\) with \(\mathbf{n}_i\) the contact normal, \(\mathbf{x}^{\text{prev}}\) is the mesh vertices from the previous time step. \(\mu\) and
        \(f^{\text{contact}}_{i}\) denote the friction coefficient and the contact force, respectively. \(\varepsilon\) is a small constant (\(\varepsilon=0.01\) mm) needed because
        \(\mathbf{x}=\mathbf{x}^{\text{prev}}\) at the very first Newton step. \(f^{\text{contact}}_{i}\) is obtained when appending contact barriers to the system matrix; thus, it is the first
        derivative of the barrier potential. Note that scaling by mass or area should not be included because \(f^{\text{contact}}_{i}\) accounts for it.
      </p>
      <p>
        Since the stiffness \(\bar{\kappa}^{\text{friction}}_{i}\) depends on the contact forces, we update the stiffness after the contact forces are computed. This value is then used to compute the
        Hessians and forces. Readers may notice that the stiffness (eigenvalue) of the Hessian above becomes \(\mu\,f^{\text{contact}}_{i}/\varepsilon\) at the very first Newton step, which can be
        very high depending on the magnitude of \(\mu\,f^{\text{contact}}_{i}\). If this issue must be addressed, one may cap \(\bar{\kappa}^{\text{friction}}_{i}\) by
        \(\partial^{2}\Psi_{\text{weak}}/\partial g_i^{2}\) (the maximal eigenvalue of the contact barrier) when computing the Hessian of the frictional potential while retaining the force itself
        intact. As we will show, a sufficient number of Newton’s steps (we suggest 32) is needed for the resulting animations to closely match the specified friction coefficient \(\mu\).
      </p>
    </div>
    <!-- ================= 4 RESULTS (incl. Bending & Rod Stiffness) ================= -->
    <div class="trans">
      <h3>4 结果（Results）</h3>
      <p>
        补充材料中的视频以 <code>&lt;xxx.mp4&gt;</code> 标注。我们使用 <strong>3×3 分块 Jacobi-PCG</strong>， 以 \(L_{\infty}\) 范数的相对残差 \(10^{-3}\) 为收敛阈值。运行硬件为 headless Ubuntu/Linux
        上的单张 RTX&nbsp;4090（托管于 vast.ai）。 主机侧采用 <strong>Rust</strong> [Matsakis and Klock&nbsp;2014]（出于安全性考虑），设备侧采用 <strong>C/C++ CUDA</strong> [Cook&nbsp;2012] 与
        <strong>Eigen</strong> [Guennebaud et&nbsp;al.&nbsp;2010]。
      </p>
      <p>图 1 的关键数值汇总见表 1；内嵌视频对应的数值见补充材料。我们在视频中叠加了随时间变化的数字与计时， 便于客观评估。元素数量（如三角形与四面体数）也在视频中给出。</p>
      <p>
        在统计接触数量时，我们去除了边-边与点-三角查询产生的重复；实现细节见补充材料。 体弹性采用 <strong>Stable Neo-Hookean</strong> [Smith et&nbsp;al.&nbsp;2018]；壳体采用
        <strong>Wikin-Baraff</strong> 模型 [Kim&nbsp;2020] 或 <strong>ARAP</strong> [Stomakhin et&nbsp;al.&nbsp;2013]；细杆采用 <strong>胡克弹簧</strong> [Liu et&nbsp;al.&nbsp;2013]。
        空气动力学建模为二次能量，惩罚速度与环境风在法向方向的差异（详见补充材料）。
      </p>
      <p>
        所有示例均在<strong>单精度</strong>下运行，包括设备侧的线性代数；主机侧的部分操作（如 PCG 的 \(\alpha,\beta\) 系数）
        以及预处理（如三角剖分）使用双精度，但对效率/内存无影响。每一步结束后，我们用
        <strong>边-三角相交测试</strong> [Möller and Trumbore&nbsp;2005] 显式确认无相交。代码已公开于 GitHub（见文中脚注）。 注意我们确实做了<strong>边-边 CCD</strong
        >，但并不做边-边离散时刻的相交检查；一旦发生穿透，离散时刻将无法检测到相交。
      </p>

      <h4>弯曲与细杆刚度（Bending and Rod Stiffness）</h4>
      <p>我们对壳体与细杆都使用了<strong>二面角</strong>型弯曲能的变体 [Grinspun et al. 2003]， 并对细杆的拉伸能量采用胡克定律。各场景的弯曲系数与刚度数值见右侧内嵌表。</p>
      <p>
        对于壳体，弯曲能量为 \[ \sum_{j}\tfrac12\,\kappa^{\text{shell}}_{\text{bend}}\,h_j\,l_j\,\theta_j^{2}, \] 其中 \(\kappa^{\text{shell}}_{\text{bend}}\) 与 \(l_j\)
        分别为壳的弯曲刚度与铰长；\(h_j\) 为厚度（等于间隙的两倍）； \(\theta_j\) 是铰处两侧法线之间的夹角。
      </p>
      <p>
        细杆的弯曲能量同样写作 \[ \sum_{j}\tfrac12\,m_j\,\kappa^{\text{rod}}_{\text{bend}}\,\theta_j^{2}, \] 其中 \(\theta_j\) 为入射到该顶点的两条边法线的夹角，\(m_j\) 为顶点质量。
        这些能量的导数直接加入全局力向量（以 SI 单位记录）。 细杆<strong>不包含扭转能</strong>；我们的细杆示例也<strong>不施加应变限制</strong>。
      </p>
      <p>
        细杆的拉伸能量为 \[ \sum_{j}\tfrac12\,\kappa_{\text{rod}}\,m^{\text{rod}}_{j}\,\bigl(l_j-l_{0,j}\bigr)^{2}, \] 其中 \(m^{\text{rod}}_{j}\) 为杆段质量，\(l_j\) 为当前边（杆段）长度，\(l_{0,j}\)
        为第 \(j\) 条边的静止长度。 细杆拉伸刚度取值为：图 1B 使用 \(\kappa_{\text{rod}}=10^{5}\)，图 1C 使用 \(\kappa_{\text{rod}}=10^{3}\)。
      </p>
      <h4>弯曲系数与刚度（用于壳与细杆）</h4>
      <table border="1" cellpadding="6" cellspacing="0">
        <thead>
          <tr>
            <th>场景（Scene）</th>
            <th>\(\kappa^{\text{shell}}_{\text{bend}}\)</th>
            <th>\(\kappa^{\text{rod}}_{\text{bend}}\)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Fig 1A</td>
            <td>500</td>
            <td></td>
          </tr>
          <tr>
            <td>Fig 1B</td>
            <td></td>
            <td>\(10^{-3}\)</td>
          </tr>
          <tr>
            <td>Fig 1C</td>
            <td></td>
            <td>5.0</td>
          </tr>
          <tr>
            <td>Fig 1D</td>
            <td>1000</td>
            <td></td>
          </tr>
          <tr>
            <td>Fig 1E</td>
            <td>40</td>
            <td></td>
          </tr>
          <tr>
            <td>Fig 1G</td>
            <td>\(10^{6}\)</td>
            <td></td>
          </tr>
          <tr>
            <td>Fig 1H</td>
            <td>2.5</td>
            <td></td>
          </tr>
          <tr>
            <td>§ 5.11</td>
            <td>1.0</td>
            <td></td>
          </tr>
        </tbody>
      </table>
      <br />
      <h4>表 1　时间拆分与关键场景参数</h4>
      <p>
        注：时间格式为“所有帧平均 / 最高 10 帧平均”。\(\#N\) 为牛顿步的平均次数。 \(\hat{\mu},\hat{\rho},\hat{\lambda}\) 分别表示杨氏模量、密度与泊松比。内嵌视频的数据见补充材料。 Fig&nbsp;1G
        的牛顿步数为固定值。
      </p>

      <!-- 上半：时间拆分 -->
      <table border="1" cellpadding="3" cellspacing="0" style="font-size: 0.9rem;">
        <thead>
          <tr>
            <th>场景<br />(Scene)</th>
            <th>矩阵组装<br />(Mat Assembly)</th>
            <th>预条件共轭梯度<br />(PCG)</th>
            <th>直线搜索<br />(Line Search)</th>
            <th>单步时间<br />(Time Per Step)</th>
            <th>每帧用时<br />(Per Frame)</th>
            <th>接触数<br />(Contact Count)</th>
            <th>步长<br />(Step Size)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Fig 1A</td>
            <td>19.27s (39.97s)</td>
            <td>21.96s (59.63s)</td>
            <td>3.06s (6.31s)</td>
            <td>109s (263s)</td>
            <td>194s (714s)</td>
            <td>100.57M (168.35M)</td>
            <td>10.0ms</td>
          </tr>
          <tr>
            <td>Fig 1B</td>
            <td>540ms (644ms)</td>
            <td>334ms (502ms)</td>
            <td>30ms (126ms)</td>
            <td>13.13s (28.56s)</td>
            <td>745s (2036s)</td>
            <td>5.50M (6.04M)</td>
            <td>5.0ms</td>
          </tr>
          <tr>
            <td>Fig 1C</td>
            <td>622ms (1.02s)</td>
            <td>69ms (195ms)</td>
            <td>41ms (78ms)</td>
            <td>2.38s (5.32s)</td>
            <td>247s (395s)</td>
            <td>4.37M (6.49M)</td>
            <td>1.0ms</td>
          </tr>
          <tr>
            <td>Fig 1D</td>
            <td>1.58s (3.70s)</td>
            <td>212ms (1.45s)</td>
            <td>260ms (521ms)</td>
            <td>5.14s (42.18s)</td>
            <td>184s (1206s)</td>
            <td>5.81M (17.59M)</td>
            <td>1.0ms</td>
          </tr>
          <tr>
            <td>Fig 1E</td>
            <td>19ms (52ms)</td>
            <td>10ms (74ms)</td>
            <td>1ms (6ms)</td>
            <td>149ms (972ms)</td>
            <td>3.30s (27.90s)</td>
            <td>6.14K (17.05K)</td>
            <td>1.0ms</td>
          </tr>
          <tr>
            <td>Fig 1F</td>
            <td>1.47s (4.88s)</td>
            <td>1.56s (2.31s)</td>
            <td>214ms (646ms)</td>
            <td>10.62s (122s)</td>
            <td>196s (704s)</td>
            <td>1.34M (2.89M)</td>
            <td>1.0ms</td>
          </tr>
          <tr>
            <td>Fig 1G</td>
            <td>21ms (31ms)</td>
            <td>52ms (130ms)</td>
            <td>1ms (4ms)</td>
            <td>3.04s (5.41s)</td>
            <td>5.04s (9.86s)</td>
            <td>58.76K (93.14K)</td>
            <td>10.0ms</td>
          </tr>
          <tr>
            <td>Fig 1H</td>
            <td>455ms (1.23s)</td>
            <td>48ms (296ms)</td>
            <td>34ms (132ms)</td>
            <td>2.11s (10.88s)</td>
            <td>77.35s (217s)</td>
            <td>2.78M (5.63M)</td>
            <td>1.0ms</td>
          </tr>
        </tbody>
      </table>

      <!-- 下半：场景参数 -->
      <br />
      <table border="1" cellpadding="3" cellspacing="0" style="font-size: 0.9rem;">
        <thead>
          <tr>
            <th>场景<br />(Scene)</th>
            <th>顶点数<br />(#Vert)</th>
            <th>壳体<br />(Shell) \((\hat{\mu},\,\hat{\rho}\,[\mathrm{kg/m^3}],\,\hat{\lambda})\)</th>
            <th>四面体<br />(Tet) \((\hat{\mu},\,\hat{\rho}\,[\mathrm{kg/m^3}],\,\hat{\lambda})\)</th>
            <th>质量比<br />(Mass Rat)</th>
            <th>尺寸(米)<br />(Dimension) (m)</th>
            <th>
              间隙<br />
              \(\hat{g}\) (\(\hat{g}\))
            </th>
            <th>\(\tau+\hat{\varepsilon}\)</th>
            <th>
              平均牛顿步数<br />
              \(\#N\)
            </th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Fig 1A</td>
            <td>8.21M</td>
            <td>10 MPa, \(10^{3}\), 0.25</td>
            <td>N/A</td>
            <td>N/A</td>
            <td>5.33 &times; 5.13 &times; 5.18</td>
            <td>1.75&nbsp;mm</td>
            <td>N/A</td>
            <td>1.0</td>
          </tr>
          <tr>
            <td>Fig 1B</td>
            <td>2.72M</td>
            <td>N/A</td>
            <td>N/A</td>
            <td>N/A</td>
            <td>2.50 &times; 1.00 &times; 1.00</td>
            <td>0.12&nbsp;mm</td>
            <td>N/A</td>
            <td>8.7</td>
          </tr>
          <tr>
            <td>Fig 1C</td>
            <td>2.25M</td>
            <td>N/A</td>
            <td>N/A</td>
            <td>N/A</td>
            <td>0.50 &times; 80.00 &times; 0.50</td>
            <td>0.50&nbsp;mm</td>
            <td>N/A</td>
            <td>2.0</td>
          </tr>
          <tr>
            <td>Fig 1D</td>
            <td>1.71M</td>
            <td>100 KPa, \(10^{3}\), 0.25</td>
            <td>1 MPa, \(2\times10^{3}\), 0.35</td>
            <td>1.10</td>
            <td>1.90 &times; 179.65 &times; 1.40</td>
            <td>1.00&nbsp;mm</td>
            <td>5%</td>
            <td>1.4</td>
          </tr>
          <tr>
            <td>Fig 1E</td>
            <td>56.47K</td>
            <td>1 MPa, \(10^{3}\), 0.25</td>
            <td>N/A</td>
            <td>N/A</td>
            <td>4.76 &times; 1.29 &times; 0.86</td>
            <td>3.00&nbsp;mm</td>
            <td>10%</td>
            <td>2.0</td>
          </tr>
          <tr>
            <td>Fig 1F</td>
            <td>6.40M</td>
            <td>N/A</td>
            <td>150 KPa, \(10^{2}\), 0.45</td>
            <td>N/A</td>
            <td>2.05 &times; 2.05 &times; 2.05</td>
            <td>0.25&nbsp;mm</td>
            <td>N/A</td>
            <td>1.6</td>
          </tr>
          <tr>
            <td>Fig 1G</td>
            <td>43.54K</td>
            <td>30 MPa, \(10^{3}\), 0.25</td>
            <td>500 KPa, \(10^{3}\), 0.35</td>
            <td>5.80</td>
            <td>8.04 &times; 5.44 &times; 1.00</td>
            <td>1.00&nbsp;mm</td>
            <td>5%</td>
            <td>32</td>
          </tr>
          <tr>
            <td>Fig 1H</td>
            <td>600.77K</td>
            <td>100 KPa, \(10^{3}\), 0.25</td>
            <td>25 MPa, \(5\times10^{4}\), 0.35</td>
            <td>41.24</td>
            <td>2.83 &times; 1.60 &times; 2.83</td>
            <td>1.00&nbsp;mm</td>
            <td>5%</td>
            <td>2.8</td>
          </tr>
        </tbody>
      </table>
      <br />
    </div>

    <div class="ori">
      <h3>4 RESULTS</h3>
      <p>
        We use the notation <code>&lt;xxx.mp4&gt;</code> for videos in the supplementary material. We used a 3×3 block diagonal-Jacobi PCG method with a tolerance of a relative residual of \(10^{-3}\)
        in the \(L_{\infty}\) norm. Our runtime hardware is a single RTX4090 on a headless Ubuntu/Linux platform hosted by vast.ai. The host side is implemented with Rust [Matsakis and Klock 2014] for
        safety reasons, and the device side is implemented with C/C++ CUDA [Cook 2012] and Eigen [Guennebaud et al. 2010].
      </p>
      <p>
        The important numbers for Figure 1 are summarized in Table 1. The numbers for the videos shown in the insets are summarized in the supplementary material. We overlay dynamically changing
        numbers and timings in the video to let readers more objectively evaluate our work. The number of element counts, such as triangles and tetrahedra, is available in the video.
      </p>
      <p>
        We eliminate duplicates in contact counts that arise in edge–edge and point–triangle queries. We detail how we achieve this in the supplementary material. We use the Stable Neo-Hookean model
        [Smith et al. 2018] for volumetric elasticity, the Wikin-Baraff model [Kim 2020] or ARAP [Stomakhin et al. 2013] for shells, and the Hooke spring [Liu et al. 2013] model for rods. Air dynamics
        is defined as a quadratic energy that penalizes differences between velocity and the ambient wind in the normal direction. This is detailed in the supplementary material.
      </p>
      <p>
        All examples run in single precision, including device-side linear algebra operations in PCG. Some host-side operations (e.g., \(\alpha\) and \(\beta\) coefficients in PCG) and
        pre-computations (e.g., mesh triangulation) are performed in double precision because they do not impact runtime efficiency or memory usage at all. All examples are explicitly checked
        intersection-free at the end of all the steps using an edge-triangle intersection test [Möller and Trumbore 2005]. Interested readers are referred to the code posted on our public GitHub
        repository. Note that we do perform edge-edge continuous collision detection (CCD), but edge-edge intersection checks are not carried out. Once a pass-through occurs, intersections cannot be
        detected at discrete timings.
      </p>

      <h4>Bending and Rod Stiffness.</h4>
      <p>
        We used variants of <em>dihedral angle–based</em> bending energies for both shells and rods [Grinspun et al. 2003] and applied Hooke’s law for rod stretching energies. Bending coefficients and
        stiffness values are listed in the table on the right inset.
      </p>
      <p>
        For shells, the energy is given by \[ \sum_{j}\tfrac12\,\kappa^{\text{shell}}_{\text{bend}}\,h_j\,l_j\,\theta_j^{2}, \] where \(\kappa^{\text{shell}}_{\text{bend}}\) and \(l_j\) are the shell
        bending stiffness and hinge length. \(h_j\) is the thickness, which is twice the gap distance. The angle \(\theta_j\) is the angle between the two normals incident to the hinge.
      </p>
      <p>
        The bending energy for rods is similarly given by \[ \sum_{j}\tfrac12\,m_j\,\kappa^{\text{rod}}_{\text{bend}}\,\theta_j^{2}, \] where \(\theta_j\) is the angle between the two edge normals
        incident to the vertex, and \(m_j\) is a vertex mass. These energy derivatives are directly plugged into the global force vector, which is recorded in SI units. Rods do not have twisting
        energies. Strain limiting is not enforced for rod examples.
      </p>
      <p>
        Rod’s stretching energy is given by \[ \sum_{j}\tfrac12\,\kappa_{\text{rod}}\,m^{\text{rod}}_{j}\,\bigl(l_j-l_{0,j}\bigr)^{2}, \] where \(m^{\text{rod}}_{j}\) is a rod mass, \(l_j\) is the
        current edge length and \(l_{0,j}\) is the \(j\)-th rest edge length. Rod stretch stiffness \(\kappa_{\text{rod}}\) is \(10^{5}\) for Figure&nbsp;1B and \(10^{3}\) for Figure&nbsp;1C.
      </p>
      <h4>Bending and Rod Stiffness (table)</h4>
      <table border="1" cellpadding="6" cellspacing="0">
        <thead>
          <tr>
            <th>Scene</th>
            <th>\(\kappa^{\text{shell}}_{\text{bend}}\)</th>
            <th>\(\kappa^{\text{rod}}_{\text{bend}}\)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Fig 1A</td>
            <td>500</td>
            <td></td>
          </tr>
          <tr>
            <td>Fig 1B</td>
            <td></td>
            <td>\(10^{-3}\)</td>
          </tr>
          <tr>
            <td>Fig 1C</td>
            <td></td>
            <td>5.0</td>
          </tr>
          <tr>
            <td>Fig 1D</td>
            <td>1000</td>
            <td></td>
          </tr>
          <tr>
            <td>Fig 1E</td>
            <td>40</td>
            <td></td>
          </tr>
          <tr>
            <td>Fig 1G</td>
            <td>\(10^{6}\)</td>
            <td></td>
          </tr>
          <tr>
            <td>Fig 1H</td>
            <td>2.5</td>
            <td></td>
          </tr>
          <tr>
            <td>§ 5.11</td>
            <td>1.0</td>
            <td></td>
          </tr>
        </tbody>
      </table>
      <br />
      <h4>Table 1. Timing breakdown and important scene numbers</h4>
      <p>
        Timing breakdown is formatted as Average of all / Average of 10 highest. \(\#N\) refers to the average of Newton’s steps. \(\hat{\mu},\hat{\rho},\hat{\lambda}\) refer to Young’s modulus,
        density and the Poisson’s ratio. Numbers for the insets are provided in the supplementary material. Newton’s steps for Fig&nbsp;1G are fixed.
      </p>

      <!-- upper: timings -->
      <table border="1" cellpadding="6" cellspacing="0">
        <thead>
          <tr>
            <th>Scene</th>
            <th>Mat Assembly</th>
            <th>PCG</th>
            <th>Line Search</th>
            <th>Time Per Step</th>
            <th>Per Frame</th>
            <th>Contact Count</th>
            <th>Step Size</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Fig 1A</td>
            <td>19.27s (39.97s)</td>
            <td>21.96s (59.63s)</td>
            <td>3.06s (6.31s)</td>
            <td>109s (263s)</td>
            <td>194s (714s)</td>
            <td>100.57M (168.35M)</td>
            <td>10.0ms</td>
          </tr>
          <tr>
            <td>Fig 1B</td>
            <td>540ms (644ms)</td>
            <td>334ms (502ms)</td>
            <td>30ms (126ms)</td>
            <td>13.13s (28.56s)</td>
            <td>745s (2036s)</td>
            <td>5.50M (6.04M)</td>
            <td>5.0ms</td>
          </tr>
          <tr>
            <td>Fig 1C</td>
            <td>622ms (1.02s)</td>
            <td>69ms (195ms)</td>
            <td>41ms (78ms)</td>
            <td>2.38s (5.32s)</td>
            <td>247s (395s)</td>
            <td>4.37M (6.49M)</td>
            <td>1.0ms</td>
          </tr>
          <tr>
            <td>Fig 1D</td>
            <td>1.58s (3.70s)</td>
            <td>212ms (1.45s)</td>
            <td>260ms (521ms)</td>
            <td>5.14s (42.18s)</td>
            <td>184s (1206s)</td>
            <td>5.81M (17.59M)</td>
            <td>1.0ms</td>
          </tr>
          <tr>
            <td>Fig 1E</td>
            <td>19ms (52ms)</td>
            <td>10ms (74ms)</td>
            <td>1ms (6ms)</td>
            <td>149ms (972ms)</td>
            <td>3.30s (27.90s)</td>
            <td>6.14K (17.05K)</td>
            <td>1.0ms</td>
          </tr>
          <tr>
            <td>Fig 1F</td>
            <td>1.47s (4.88s)</td>
            <td>1.56s (2.31s)</td>
            <td>214ms (646ms)</td>
            <td>10.62s (122s)</td>
            <td>196s (704s)</td>
            <td>1.34M (2.89M)</td>
            <td>1.0ms</td>
          </tr>
          <tr>
            <td>Fig 1G</td>
            <td>21ms (31ms)</td>
            <td>52ms (130ms)</td>
            <td>1ms (4ms)</td>
            <td>3.04s (5.41s)</td>
            <td>5.04s (9.86s)</td>
            <td>58.76K (93.14K)</td>
            <td>10.0ms</td>
          </tr>
          <tr>
            <td>Fig 1H</td>
            <td>455ms (1.23s)</td>
            <td>48ms (296ms)</td>
            <td>34ms (132ms)</td>
            <td>2.11s (10.88s)</td>
            <td>77.35s (217s)</td>
            <td>2.78M (5.63M)</td>
            <td>1.0ms</td>
          </tr>
        </tbody>
      </table>

      <!-- lower: scene numbers -->
      <br />
      <table border="1" cellpadding="6" cellspacing="0">
        <thead>
          <tr>
            <th>Scene</th>
            <th>#Vert</th>
            <th>Shell (\(\hat{\mu},\hat{\rho}\,[\mathrm{kg/m^3}],\hat{\lambda}\))</th>
            <th>Tet (\(\hat{\mu},\hat{\rho}\,[\mathrm{kg/m^3}],\hat{\lambda}\))</th>
            <th>Mass Rat</th>
            <th>Dimension (m)</th>
            <th>\(\hat{g}\)</th>
            <th>\(\tau+\hat{\varepsilon}\)</th>
            <th>\(\#N\)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Fig 1A</td>
            <td>8.21M</td>
            <td>10 MPa, \(10^{3}\), 0.25</td>
            <td>N/A</td>
            <td>N/A</td>
            <td>5.33 &times; 5.13 &times; 5.18</td>
            <td>1.75&nbsp;mm</td>
            <td>N/A</td>
            <td>1.0</td>
          </tr>
          <tr>
            <td>Fig 1B</td>
            <td>2.72M</td>
            <td>N/A</td>
            <td>N/A</td>
            <td>N/A</td>
            <td>2.50 &times; 1.00 &times; 1.00</td>
            <td>0.12&nbsp;mm</td>
            <td>N/A</td>
            <td>8.7</td>
          </tr>
          <tr>
            <td>Fig 1C</td>
            <td>2.25M</td>
            <td>N/A</td>
            <td>N/A</td>
            <td>N/A</td>
            <td>0.50 &times; 80.00 &times; 0.50</td>
            <td>0.50&nbsp;mm</td>
            <td>N/A</td>
            <td>2.0</td>
          </tr>
          <tr>
            <td>Fig 1D</td>
            <td>1.71M</td>
            <td>100 KPa, \(10^{3}\), 0.25</td>
            <td>1 MPa, \(2\times10^{3}\), 0.35</td>
            <td>1.10</td>
            <td>1.90 &times; 179.65 &times; 1.40</td>
            <td>1.00&nbsp;mm</td>
            <td>5%</td>
            <td>1.4</td>
          </tr>
          <tr>
            <td>Fig 1E</td>
            <td>56.47K</td>
            <td>1 MPa, \(10^{3}\), 0.25</td>
            <td>N/A</td>
            <td>N/A</td>
            <td>4.76 &times; 1.29 &times; 0.86</td>
            <td>3.00&nbsp;mm</td>
            <td>10%</td>
            <td>2.0</td>
          </tr>
          <tr>
            <td>Fig 1F</td>
            <td>6.40M</td>
            <td>N/A</td>
            <td>150 KPa, \(10^{2}\), 0.45</td>
            <td>N/A</td>
            <td>2.05 &times; 2.05 &times; 2.05</td>
            <td>0.25&nbsp;mm</td>
            <td>N/A</td>
            <td>1.6</td>
          </tr>
          <tr>
            <td>Fig 1G</td>
            <td>43.54K</td>
            <td>30 MPa, \(10^{3}\), 0.25</td>
            <td>500 KPa, \(10^{3}\), 0.35</td>
            <td>5.80</td>
            <td>8.04 &times; 5.44 &times; 1.00</td>
            <td>1.00&nbsp;mm</td>
            <td>5%</td>
            <td>32</td>
          </tr>
          <tr>
            <td>Fig 1H</td>
            <td>600.77K</td>
            <td>100 KPa, \(10^{3}\), 0.25</td>
            <td>25 MPa, \(5\times10^{4}\), 0.35</td>
            <td>41.24</td>
            <td>2.83 &times; 1.60 &times; 2.83</td>
            <td>1.00&nbsp;mm</td>
            <td>5%</td>
            <td>2.8</td>
          </tr>
        </tbody>
      </table>
      <br />
    </div>
    <!-- ============== 4.1 Noodle Bowl ============== -->
    <div class="trans">
      <h4>4.1 面碗（Noodle Bowl）</h4>
      <p>
        图 1C 展示了一个包含 225 万顶点的示例，其中 624 条长杆被倒入一个不可见的半球碗内，总计产生 649 万次接触。 当所有杆落入容器后，它们在不冻结的情况下达到静态平衡 [Daviet et al. 2011; Erleben
        2004; Schmidl and Milenkovic 2004]。 每帧视频用时 247s，推进一步消耗 2.0 次牛顿迭代。 对于细杆，我们施加了 1.50&nbsp;mm 的绝对厚度偏移，以确保它们在自身半径处不会互相接触；
        仅依赖我们的动态刚度并不能保证这种“绝对分离”。
      </p>
      <p>另外，为了在倒入之前稳定远端顶部“面条”的水平位置，我们对相机视野之外的顶点施加了一个 弱的人工二次能量，用以惩罚水平位移。</p>
    </div>
    <div class="ori">
      <h4>4.1 Noodle Bowl</h4>
      <p>
        Figure 1C shows an example with 2.25 million vertices in which 624 lengthy rods are poured into an invisible hemispherical bowl, totaling 6.49 million contacts. After all the rods are poured
        into the container, they settle into a static equilibrium state without freezing [Daviet et al. 2011; Erleben 2004; Schmidl and Milenkovic 2004]. Each video frame took 247s and the 2.0
        Newton’s steps are consumed to advance a step. For rods, we applied an absolute offset thickness of 1.50&nbsp;mm to ensure they do not touch at their radii, as relying solely on our dynamic
        stiffness does not guarantee such absolute separation.
      </p>
      <p>
        Also, to stabilize the horizontal positions of the noodles at the far top before being poured, we applied a weak artificial quadratic energy that penalizes horizontal displacements for
        vertices located outside the camera’s visibility.
      </p>
    </div>
    <!-- ============== 4.2 Woven Cylinder ============== -->
    <div class="trans">
      <h4>4.2 织筒（Woven Cylinder）</h4>
      <p>
        图 1B 显示了由 1626 条细杆、272 万顶点组成的织筒在扭转并起皱的过程。 这一案例尤其具有挑战性，因为依赖于显式纱线结构知识的处理方法 [Cirio et al. 2014, 2017] 在远距离纱线碰撞存在时不可用。
        既有工作依赖较小步长以避免“穿透拉出”[Kaldor et al. 2008, 2010; Yuksel et al. 2012]， 这些方法在任意大的步长下容易出现自交。 每帧视频用时 745s，推进一步消耗 8.7 次牛顿迭代。 我们同样施加了
        1.50&nbsp;mm 的绝对厚度偏移（理由同 §&nbsp;4.1）。 旋转角速度为 \(\pi\) 弧度/秒。
      </p>
    </div>
    <div class="ori">
      <h4>4.2 Woven Cylinder</h4>
      <p>
        Figure 1B shows a woven cylinder made of 1626 rods and 2.72 million vertices being twisted and buckled. This is particularly challenging because treatments that rely on explicit knowledge of
        yarn structures [Cirio et al. 2014, 2017] are not applicable due to distant yarn collisions. Since prior works depend on small steps to prevent pull-through [Kaldor et al. 2008, 2010; Yuksel
        et al. 2012], these methods are subject to self-intersections at arbitrarily large steps. Each video frame took 745s and the 8.7 Newton’s steps are consumed to advance a step. We have also
        applied an absolute offset of 1.50&nbsp;mm for the same reason as described in &sect;&nbsp;4.1. The rotational angular velocity is \(\pi\) radians per second.
      </p>
    </div>
    <!-- ============== 4.3 Guided Fitting ============== -->
    <div class="trans">
      <h4>4.3 引导式缝合（Guided Fitting）</h4>
      <p>
        右侧内嵌视频 &lt;fitting.mp4&gt; 演示了使用 Li et&nbsp;al. [2021] 的一组版型进行引导式缝合。 为了搭建该配置，我们对缝合能使用了简单的二次能量 \(\lvert g-\hat g\rvert^2\)，
        并在表演阶段省略了惯性项和重力。 每帧视频用时 891ms，推进一步消耗 2.1 次牛顿迭代。 我们使用了两个步长：表演阶段 \(\Delta t=1\)ms，其余为 \(\Delta t=10\)ms。 应变限制设为
        10%。我们尝试过更严格的限制，但在表演阶段需要一定的拉伸以便将缝合边对齐缝合。
      </p>
    </div>
    <div class="fig">
      <img src="img/4_3.jpeg" alt="Figure 4.3: Guided Fitting Example" class="internal_fig_img" />
      <figcaption>内联图 4.3：引导式缝合</figcaption>
    </div>
    <div class="ori">
      <h4>4.3 Guided Fitting</h4>
      <p>
        The right inset &lt;fitting.mp4&gt; is an example staging a set of cloth patterns from Li et al. [2021] for guided fitting. To set up this configuration, we used a simple quadratic energy
        \(\lvert g-\hat g\rvert^2\) for stitch energy, omitting both the inertial term and gravity during staging. Each video frame took 891ms and the 2.1 Newton’s steps are consumed to advance a
        step. We used two step sizes: \(\Delta t=1\)ms during staging and \(\Delta t=10\)ms for the rest. Strain limiting is set to 10%. We tried a more severe strain limiting, but some amount of
        stretch was necessary to allow seams to be stitched together during staging.
      </p>
    </div>

    <!-- ============== 4.4 Reef and Fishing Knots ============== -->
    <div class="trans">
      <h4>4.4 平结与渔人结（Reef and Fishing Knots）</h4>
      <p>
        图 1E 及右侧内嵌视频 &lt;knot.mp4&gt; 展示了两种不同的收紧结：其中平结参考 Harmon et&nbsp;al. [2009]。 在这些示例中，我们采用了<strong>共旋转</strong>畸变能 [Kim and Eberle 2022; Lan et al.
        2022; Stomakhin et al. 2013]， 因为 Baraff–Witkin 模型需要显式的正交基信息。 每帧视频分别用时 3.30s（渔人结）与 2.29s（平结）。 平均牛顿步数分别为 2.0 和 2.1。
      </p>
    </div>
    <div class="fig">
      <img src="img/4_4.jpeg" alt="Figure 4.4: Reef and Fishing Knots" class="internal_fig_img" />
      <figcaption>内联图 4.4：平结与渔人结</figcaption>
    </div>
    <div class="ori">
      <h4>4.4 Reef and Fishing Knots</h4>
      <p>
        Figure 1E and the right inset &lt;knot.mp4&gt; illustrate two different types of knots being tightened, with the reef knot from Harmon et al. [2009]. In these examples, we used co-rotational
        distortion energy [Kim and Eberle 2022; Lan et al. 2022; Stomakhin et al. 2013] because the Baraff–Witkin model requires explicit knowledge of orthogonal bases. Each video frame took 3.30s for
        the fishing knot example and 2.29s for the reef knot. Average Newton’s steps are 2.0 for the fishing knot and 2.1 for the reef knot example.
      </p>
    </div>
    <!-- ============== 4.5 Squishy Balls ============== -->
    <div class="trans">
      <h4>4.5 柔软小球（Squishy Balls）</h4>
      <p>
        图 1F 演示了一个具有挑战性的碰撞场景：来自 Zheng 与 James [2012] 的 8 个可压缩小球被紧密装入球形容器，随后释放到空中。 该示例包含 2468 万个四面体单元与 640 万个顶点。每帧用时
        196s，推进一步消耗 1.6 次牛顿迭代。 尽管我们的方法是半隐式的，但值得强调的是，在小球被压缩的过程中依旧保持稳定。 需要注意的是，当 8
        个小球释放时，我们切换为<strong>十分之一速</strong>的慢动作模式；否则小球会过快飞离。
      </p>
    </div>
    <div class="ori">
      <h4>4.5 Squishy Balls</h4>
      <p>
        Figure 1F demonstrates a challenging collision scenario in which eight squishy balls from Zheng and James [2012] are tightly packed inside a spherical container and then released into the air.
        This example consists of 24.68 million tetrahedral elements and 6.40 million vertices. Each video frame took 196s and the 1.6 Newton’s steps are consumed to advance a step. Despite our method
        being semi-implicit, it is worth highlighting that during the compression of the squishy balls, they remain stable. Note that when the eight balls are released, we switched to ten-times slower
        slow-motion mode; otherwise, the balls would fly away too quickly.
      </p>
    </div>
    <!-- ============== 4.6 Frictional Contacts ============== -->
    <div class="trans">
      <h4>4.6 含摩擦接触（Frictional Contacts）</h4>
      <p>
        图 1G 展示了一个倒塌的纸牌屋（\(\mu=0.4\)）。我们强调：在动画后段，场景完全停止，
        <strong>静摩擦</strong>维持了直立纸牌之间微妙的平衡。上方内嵌 <code>&lt;belt.mp4&gt;</code>
        展示了旋转圆柱与三条被<strong>紧张拉紧</strong>的传送带（\(\mu=0.5\)）。当圆柱开始旋转时，
        传送带的每一层都会响应下方的旋转，三条带子同步转动；而当张紧不够（同一视频所示），直线条纹将不再保持。
      </p>
      <p>下方内嵌 <code>&lt;domino.mp4&gt;</code> 为多米诺骨牌连锁（\(\mu=0.1\)）。在整体倒塌后，系统短暂进入平衡， 随后因从静摩擦过渡到动摩擦而触发轻微的滑移。</p>
      <p>
        为获得准确的摩擦结果，需要<strong>足够多</strong>的牛顿步。上述三个示例均使用 32 步、\(\Delta t=10\)ms， 其流程见右侧算法框。三例的平均每帧时间分别为纸牌 5.04s、传送带 22.21s、多米诺 10.78s。
      </p>

      <pre class="algo" st>
for n_iter = 1 to 32 do
  x, α ← inner_step(Δt, x)
  β ← β + (1 − β) α
end for</pre
      >
    </div>
    <div class="fig">
      <img src="img/4_6.jpeg" alt="Figure 4.6: Frictional Contacts" class="internal_fig_img" />
      <figcaption>内联图 4.6：摩擦接触</figcaption>
    </div>
    <div class="ori">
      <h4>4.6 Frictional Contacts</h4>
      <p>
        Figure 1G shows a collapsing house of cards (\(\mu=0.4\)). We highlight that towards the end of the animation, the entire scene comes to a stop, with static friction maintaining the delicate
        balance of the standing cards. The inset top &lt;belt.mp4&gt; features rotating cylinders, where three belts are tightly tensioned (\(\mu=0.5\)). As the cylinders begin to rotate, each layer
        of the belt responds to the rotation beneath it, making all three belts rotate together. When loosely tightened, as also seen in the same video, these straight patterns no longer hold.
      </p>
      <p>
        The inset bottom &lt;domino.mp4&gt; is a domino cascade (\(\mu=0.1\)). After the entire domino collapse, a short period of equilibrium is reached, followed by an abrupt but slight sliding
        motion triggered by the transition from static friction to sliding friction.
      </p>
      <p>
        As we will discuss, a sufficient number of Newton’s steps are needed for accurate frictional contacts. We used 32 steps and \(\Delta t=10\)ms for the above three examples. This is illustrated
        in the algorithm inset. Average time per video frame is 5.04s for the card example, 22.21s for the belt example and 10.78s for the domino example.
      </p>

      <pre class="algo_rev">
for n_iter = 1 to 32 do
  x, α ← inner_step(Δt, x)
  β ← β + (1 − β) α
end for</pre
      >
    </div>
    <div class="trans">
      <h5>4.6.1 未完全解析的摩擦接触（Unresolved Frictional Contacts）</h5>
      <p>
        图 1 的其他一些示例给出了 \(0 \le \mu \le 1\) 的摩擦系数（见右侧表）；未列出的示例取 \(\mu=0\)。 在这些示例中，仅有图 1G 的摩擦接触被充分解析；其余多因牛顿步较少、步长更小而未完全解析，
        相应的摩擦系数并非物理值，需要经验设定。
      </p>
      <p>
        例如在图 1B，我们最初设 \(\mu=0\)，导致织筒解缠。于是采用尽可能小的 \(\mu\) 以避免该问题。 出于安全考虑（接触力在收尾阶段可能很大），我们还对 \(\bar\kappa^{\text{friction}}_i\) 施加了
        \(\partial^2 \Psi_{\text{weak}}/\partial g_i^2\) 的上限；其他示例未做截断。关于摩擦接触的局限性详见 §6。
      </p>

      <table border="1" cellpadding="6" cellspacing="0">
        <thead>
          <tr>
            <th>场景(Scene)</th>
            <th>摩擦系数 \(\mu\) (\(\mu\))</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Fig 1B</td>
            <td>0.01</td>
          </tr>
          <tr>
            <td>Fig 1D</td>
            <td>0.5</td>
          </tr>
          <tr>
            <td>Fig 1F</td>
            <td>0.1</td>
          </tr>
          <tr>
            <td>Fig 1G</td>
            <td>0.4</td>
          </tr>
          <tr>
            <td>Fig 1H</td>
            <td>0.5</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="ori">
      <h5>4.6.1 Unresolved Frictional Contacts</h5>
      <p>
        For some other examples in Figure 1, positive frictional coefficients \(0 \le \mu \le 1\) are provided, as listed in the table on the right inset. Unlisted examples simply have \(\mu=0\). In
        these examples, Figure 1G is the only one where frictional contacts are adequately resolved, as most of the others use only a few Newton’s steps with smaller step sizes. For these unresolved
        cases, the frictional coefficients are not physical and need to be selected heuristically.
      </p>
      <p>
        For example, in Figure 1B, we initially set \(\mu=0\), but it resulted in untangled woven rods. Therefore, we used the smallest coefficient to prevent this issue. We have also capped
        \(\bar\kappa^{\text{friction}}_i\) by \(\partial^2 \Psi_{\text{weak}}/\partial g_i^2\) for safety reasons because we know contact forces can be enormous towards the end. We did not cap
        \(\bar\kappa^{\text{friction}}_i\) for other examples. Limitations on the frictional contacts are discussed in more detail in §6.
      </p>

      <table border="1" cellpadding="6" cellspacing="0">
        <thead>
          <tr>
            <th>Scene</th>
            <th>\(\mu\)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Fig 1B</td>
            <td>0.01</td>
          </tr>
          <tr>
            <td>Fig 1D</td>
            <td>0.5</td>
          </tr>
          <tr>
            <td>Fig 1F</td>
            <td>0.1</td>
          </tr>
          <tr>
            <td>Fig 1G</td>
            <td>0.4</td>
          </tr>
          <tr>
            <td>Fig 1H</td>
            <td>0.5</td>
          </tr>
        </tbody>
      </table>
    </div>
    <!-- ============== 4.7 Ribbons and Stacked Sheets ============== -->
    <div class="trans">
      <h4>4.7 丝带与堆叠薄片（Ribbons and Stacked Sheets）</h4>
      <p>
        图 1D 展示了弱接触与强接触并存且受强冲击的情况，各共维对象的质量比接近 1。 本例中，长丝带被温和地倒入透明半球碗中；当丝带几乎稳定后，一个高速下落的球体突然撞击，
        将丝带完全压下，使球体在丝带堆上多次反弹。每帧用时 184s，推进一步消耗 1.4 次牛顿迭代。
      </p>
      <p>类似的测试见图 1H：十张薄片缓慢落地，随后一个高速下落的球体强力砸下。 此例中，薄片与球体的总质量比为 41.24。每帧用时 77.35s，推进一步消耗 2.8 次牛顿迭代。</p>
      <p>由于我们的方法不会隐式调节接触刚度，像这样“多层薄片堆叠并遭遇突然压缩冲击”的情形在数值上具有挑战性。 我们的方法可稳健应对此类场景，未出现振荡不稳定或 PCG 发散。</p>
    </div>
    <div class="ori">
      <h4>4.7 Ribbons and Stacked Sheets</h4>
      <p>
        Figure 1D demonstrates the presence of both weak and tight contacts with a strong impact, with a mass ratio of different co-dimensional objects being nearly one. In this example, lengthy
        ribbons are gently poured into a transparent hemispherical bowl. Once the ribbons have nearly settled, a sudden impact from a fast-falling sphere compresses the ribbons all the way down,
        making the sphere bounce on the pile of ribbons several times. Each video frame took 184s and the 1.4 Newton’s steps are consumed to advance a step.
      </p>
      <p>
        A similar test is also performed in Figure 1H, where ten sheets slowly fall onto the ground until a fast-falling sphere strongly smashes them. In this example, the mass ratio difference
        between all the sheets and the sphere is 41.24. Each video frame took 77.35s and the 2.8 Newton’s steps are consumed to advance a step.
      </p>
      <p>
        Since our method does not implicitly adjust contact stiffness, a scenario such as this, where multiple sheets are stacked and experience a sudden compressing impact, would pose a numerical
        challenge. Our method handles such scenarios without difficulty such as oscillatory instabilities or PCG divergence.
      </p>
    </div>
    <!-- ============== 4.8 Highly Localized Strong Contact ============== -->
    <div class="trans">
      <h4>4.8 高度局部化的强接触（Highly Localized Strong Contact）</h4>
      <p>
        右侧内嵌 <code>&lt;main.mp4&gt;</code> 为受 Wang et&nbsp;al. [2023] 启发的压力测试：5 张薄片轻搭在针尖上， 并遭受落球冲击。球体质量为薄片总质量的 43.06 倍，针尖以单个顶点表示。
        我们还进行了三组附加测试：让 5 张薄片以高速下落，并在针尖处承受<strong>高度局部化</strong>冲击， 初速度分别为 5 m/s、10 m/s、20 m/s，步长为 1 ms。
      </p>
      <p>
        本节所有测试均启用了<strong>双向耦合</strong>的应变限制，严格上限为 5%，其挑战性高于 Wang et&nbsp;al. [2023]。 正如 §5.1
        将讨论的，我们的<strong>三次障碍</strong>是通过该压力测试的关键；对数障碍会失败。
      </p>
    </div>
    <div class="fig">
      <img src="img/4_8.jpeg" alt="Figure 4.8: Highly Localized Strong Contact" class="internal_fig_img" />
      <figcaption>内联图 4.8：高度局部化的强接触</figcaption>
    </div>
    <div class="ori">
      <h4>4.8 Highly Localized Strong Contact</h4>
      <p>
        The right inset &lt;main.mp4&gt; conducts a stress test inspired by Wang et al. [2023], involving five sheets gently draped on the tip of a needle and subjected to the impact of a falling
        sphere. In this setup, the sphere is 43.06 times heavier than the total sheets and the tip of the needle is represented with a single vertex. We also conducted another set of three tests in
        which five sheets fall at a high speed and are subject to a highly localized impact at the tip. This test set is composed of three initial speeds: 5 m/s, 10 m/s and 20 m/s with a step size of
        1 ms.
      </p>
      <p>
        For all the tests in this section, we activated two-way coupled strain limiting with a strict upper bound of 5%, posing greater challenges than Wang et al. [2023]. As we will discuss in §5.1,
        our cubic barrier is essential for this stress test to pass; a logarithmic counterpart fails.
      </p>
    </div>
    <!-- ============== 4.9 Five Cylinders Twisted ============== -->
    <div class="trans">
      <h4>4.9 五个圆柱片扭缠（Five Cylinders Twisted）</h4>
      <p>
        图 1A 展示了来自 Li et&nbsp;al. [2021] 的 5 张圆柱片分别扭转后再打包的示例，峰值接触数达到 1.6835×10<sup>8</sup>。
        在如此巨大的接触数下，我们的<strong>接触矩阵缓存组装</strong>不可或缺；否则峰值内存分配将无法放入 RTX4090 的 24&nbsp;GB 显存。 尽管接触极多，强度最高的时刻每帧时间仍约 714s；平均每帧时间为
        194s。顶点与面片数分别为 821 万与 1641 万。 由于运动较慢，许多时间步只需一次牛顿迭代即可。
      </p>
    </div>
    <div class="ori">
      <h4>4.9 Five Cylinders Twisted</h4>
      <p>
        Figure 1A shows an example of five cylindrical sheets from Li et al. [2021], individually twisted and bundled, peaking at 168.35 million contacts. For such a significant number of contacts,
        our cached contact matrix assembly is indispensable; otherwise, the peak memory allocation does not fit within the 24 GB of device memory for the RTX4090. We highlight that despite such a high
        contact count, the running time per frame remains around 714s even at intense moments. It is also worth noting that the average time per frame was 194s. The vertex and face counts were 8.21
        million and 16.41 million, respectively. Since the movements were slow, a single Newton step was sufficient for many time steps.
      </p>
    </div>
    <!-- ============== 4.10 Strain Limited Trampoline ============== -->
    <div class="trans">
      <h4>4.10 受限应变的“蹦床”（Strain Limited Trampoline）</h4>
      <p>
        右侧内嵌 <code>&lt;main.mp4&gt;</code> 展示了在上限为 1% 的<strong>强烈应变限制</strong>下仍能通过高冲击碰撞的测试， 例如：质量比为 32.91
        的犰狳从法向方向撞击薄片。该设定尤其具有挑战性，因为耦合较弱的系统必须在 “应变限制与可变形动力学”两类高敏感力的共同作用下维持微妙的平衡。初始下落速度分别为 5&nbsp;m/s 与 25&nbsp;m/s，时间步
        \(\Delta t=1\) ms。
      </p>
    </div>
    <div class="fig">
      <img src="img/4_10.jpeg" alt="Figure 4.10: Strain Limited Trampoline" class="internal_fig_img" />
      <figcaption>内联图 4.10：受限应变的“蹦床”压力测试</figcaption>
    </div>
    <div class="ori">
      <h4>4.10 Strain Limited Trampoline</h4>
      <p>
        The right inset &lt;main.mp4&gt; demonstrates high tolerance for severe strain limiting with an upper bound of 1%, even when subjected to a high impact collision, such as an armadillo with a
        mass difference ratio of 32.91 hitting the sheet from the normal direction. This setup is particularly challenging because a weakly coupled system may struggle to maintain a delicate balance
        sustained by highly sensitive forces of strain limiting and deformable dynamics. The initial falling speeds are 5&nbsp;m/s and 25&nbsp;m/s, respectively with \(\Delta t=1\) ms.
      </p>
    </div>

    <!-- ============== 4.11 Comparisons ============== -->
    <div class="trans">
      <h4>4.11 对比实验（Comparisons）</h4>
      <p>
        右侧内嵌上方 <code>&lt;curtain.mp4&gt;</code>：我们悬挂 15 张薄片，让移动球体在 \(\Delta t=10\) ms 下激发起伏，并至少用 8 次牛顿步。 下方我们用公开的 CIPC
        实现（脚注<sup>3</sup>）复现实验，结果表明：当牛顿步数足够时，我们的“非精确牛顿法”产生的动画与 CIPC 类似。
      </p>
      <p>
        我们还在<strong>首个牛顿步</strong>绘制了两种方法的条件数（对数坐标，见内嵌图），观察到 CIPC 的条件数通常更大。 尽管文献 [Li et&nbsp;al.&nbsp;2021] 报告了条件数问题，但后续工作 [Huang
        et&nbsp;al.&nbsp;2024] 指出其与 PCG 可配合使用。 我们的方法是 IPC 的一个变体，实验上更符合 [Huang et&nbsp;al.&nbsp;2024]：除“搜索方向锁死”外，我们未遇到由对数障碍导致的收敛问题。
        这说明接触的条件数问题只在特定情形、特定算法选择下出现，并非我们方法的一般性问题。
      </p>
      <p>说明：我们的求解并不追求“梯度趋零”的严格收敛，因此上表不能当作对 CIPC 的公平性能对比（类似地，Wang et&nbsp;al.&nbsp;[2023] 也未做相同对比。见其论文中 §8）。</p>

      <table border="1" cellpadding="6" cellspacing="0">
        <thead>
          <tr>
            <th>#Vert</th>
            <th>#N</th>
            <th>Time(s)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="4">87.2K</td>
            <td>8</td>
            <td>1.29</td>
          </tr>
          <tr>
            <td>16</td>
            <td>1.73</td>
          </tr>
          <tr>
            <td>32</td>
            <td>3.01</td>
          </tr>
          <tr>
            <td>CIPC</td>
            <td>212.47</td>
          </tr>

          <tr>
            <td rowspan="4">23.5K</td>
            <td>8</td>
            <td>0.66</td>
          </tr>
          <tr>
            <td>16</td>
            <td>0.85</td>
          </tr>
          <tr>
            <td>32</td>
            <td>1.52</td>
          </tr>
          <tr>
            <td>CIPC</td>
            <td>35.42</td>
          </tr>

          <tr>
            <td rowspan="4">8.5K</td>
            <td>8</td>
            <td>0.49</td>
          </tr>
          <tr>
            <td>16</td>
            <td>0.66</td>
          </tr>
          <tr>
            <td>32</td>
            <td>1.14</td>
          </tr>
          <tr>
            <td>CIPC</td>
            <td>8.70</td>
          </tr>
        </tbody>
      </table>
    </div>
    <div class="fig">
      <img src="img/4_11_1.jpeg" alt="Figure 4.11.1: Comparisons & Condition Numbers" class="internal_fig_img" />
      <img src="img/4_11_2.png" alt="Figure 4.11.2: Comparisons & Condition Numbers" class="internal_fig_img" />
      <figcaption>内联图 4.11：与 CIPC 的结果与条件数对比</figcaption>
    </div>
    <div class="ori">
      <h4>4.11 Comparisons</h4>
      <p>
        In the right inset &lt;curtain.mp4&gt; top, we hung 15 sheets subjected to undulation by a moving sphere with \(\Delta t=10\) ms and a minimal of 8 Newton’s steps. Additionally, in the bottom
        we simulated the same scene using a publicly available implementation<sup>3</sup> of CIPC. This shows that our inexact Newton’s method produces animations similar to those of CIPC when a
        sufficient number of Newton’s steps are selected.
      </p>
      <p>
        We also plot the condition number of both methods in log-scale at the very first Newton’s step as shown in the inset and observed that the CIPC yields larger ones than ours. Note that, despite
        the issue of conditioning has been reported [Li et al. 2021] it is shown to work with a PCG [Huang et al. 2024]. Although our work is a variant of IPC, our results are more consistent with
        those of Huang et al. [2024] in that we did not encounter convergence issues arising from the use of logarithmic barriers, except for search direction locking. This indicates that the
        conditioning issues for contacts are present only in specific cases and due to algorithmic choices, and are generally not a problem in our method.
      </p>
      <p>
        A runtime comparison for smaller scale examples is summarized in the inset &lt;cipc-comparison.mp4&gt;. The second column is either the numbers of Newton’s steps for our method or CIPC. The
        third column represents the average time per frame. CIPC was run on an AMD Ryzen 7 5700X. We emphasize that our method does not achieve exact gradient-vanishing convergence; therefore, this
        table should not be interpreted as a fair performance comparison to CIPC. For example, Wang et al. [2023] did not perform similar comparisons for fairness reasons (see §8 in their paper).
      </p>

      <table border="1" cellpadding="6" cellspacing="0">
        <thead>
          <tr>
            <th>#Vert</th>
            <th>#N</th>
            <th>Time(s)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="4">87.2K</td>
            <td>8</td>
            <td>1.29</td>
          </tr>
          <tr>
            <td>16</td>
            <td>1.73</td>
          </tr>
          <tr>
            <td>32</td>
            <td>3.01</td>
          </tr>
          <tr>
            <td>CIPC</td>
            <td>212.47</td>
          </tr>

          <tr>
            <td rowspan="4">23.5K</td>
            <td>8</td>
            <td>0.66</td>
          </tr>
          <tr>
            <td>16</td>
            <td>0.85</td>
          </tr>
          <tr>
            <td>32</td>
            <td>1.52</td>
          </tr>
          <tr>
            <td>CIPC</td>
            <td>35.42</td>
          </tr>

          <tr>
            <td rowspan="4">8.5K</td>
            <td>8</td>
            <td>0.49</td>
          </tr>
          <tr>
            <td>16</td>
            <td>0.66</td>
          </tr>
          <tr>
            <td>32</td>
            <td>1.14</td>
          </tr>
          <tr>
            <td>CIPC</td>
            <td>8.70</td>
          </tr>
        </tbody>
      </table>
    </div>

    <!-- ======================= 5 VALIDATIONS ======================= -->
    <div class="trans">
      <h3>5 验证（VALIDATIONS）</h3>
    </div>
    <div class="ori">
      <h3>5 VALIDATIONS</h3>
    </div>

    <!-- 5.1 -->
    <div class="trans">
      <h4>5.1 搜索方向锁死（Search Direction Locking）</h4>
      <p>
        锁死现象主要出现在<strong>存在应变限制</strong>时。对“五张薄片披挂在球面上”的 <code>&lt;drape.mp4&gt;</code>， 其<strong>间隙分布</strong>如右上内嵌图所示；§5.11
        的右下也给出类似图，显示应变限制是最严格的约束，因此容易受浮点精度影响。
      </p>
      <p>
        为证明问题源于对数障碍，我们将 \(\psi_{\text{weak}}\) 替换为式(2) 的 \(\psi_{\ln}\) 并保留其它部分， 运行 §4.8 与 §5.11 的示例全部失败。失败前，最小应变限制间隙分别在
        \(10^{-6}\,\text{m}\)（§4.8）与 \(10^{-7}\,\text{m}\)（§5.11）量级附近波动，条件数最终变为 NaN（单精度下不可测）。
      </p>
      <p>
        这是因为对数障碍难以在有限牛顿步内<strong>放大极小间隙</strong>。我们也测试了 [Huang&nbsp;et&nbsp;al.&nbsp;2024] 的变体，
        在临界点附近截断曲率，虽能去除锁死，但会使搜索方向突增，从而让<strong>直线搜索</strong>更严格地限制可行步长。
      </p>
      <p>
        §4.8 的<strong>时间对比</strong>见右侧内嵌图：带二次加固的对数障碍在困难时刻每帧用时可比我们长两个数量级。 原版 IPC 通过“继续牛顿循环至精确收敛 +
        双精度直接解”缓解该问题；我们未采用这些，因此该问题对 CIPC 的影响应更小。
      </p>
    </div>
    <div class="fig">
      <img src="img/5_1_1.png" alt="Figure 5.1.1: Locking & Timing" class="internal_fig_img" style="width: 15rem" />
      <img src="img/5_1_2.png" alt="Figure 5.1.2: Locking & Timing" class="internal_fig_img" style="width: 15rem" />
      <img src="img/5_1_3.png" alt="Figure 5.1.3: Locking & Timing" class="internal_fig_img" style="width: 15rem" />
      <figcaption>
        内联图 5.1：应变限制下的锁死与时间对比<span hidden="hidden"><br />y 轴 = count (log-scale); x 轴 = gap distance (m)</span>
      </figcaption>
    </div>
    <div class="ori">
      <h4>5.1 Search Direction Locking</h4>
      <p>
        First, the search direction locking mostly emerges when strain limiting exists. A real-scale gap distribution for an example where five sheets are draped on a sphere &lt;drape.mp4&gt; is
        visualized in the right inset top and §5.11 in the right bottom, which shows that the strain limiting is the most stringent constraint and thus is sensitive to floating- point accuracy.
      </p>
      <p>
        To clarify that the logarithmic barrier is a source of the issue, we have replaced \(\psi_{\text{weak}}\) with \(\psi_{\ln}\) introduced in (2) while retaining other components. When we run
        the simulation with this replacement, examples of both §4.8 and §5.11 fail. Before the moment of failure, the minimal strain limiting gap fluctuates around an order of \(10^{-6}\) m (§4.8) or
        \(10^{-7}\) m (§5.11), and the condition number eventually turns to NaN (not measurable within single-precision).
      </p>
      <p>
        This is because logarithmic barriers struggle to enlarge extremely small gaps within a limited budget of Newton’s steps. We have also tried a variant of the logarithmic barrier [Huang et al.
        2024], with curvature capped near the critical point as suggested, and confirmed the removal of the search direction locking. Instead, due to the sharp increase in the search direction, the
        line search more severely restricts the feasible step size. The above two behaviors are more clearly illustrated in the supplementary material.
      </p>
      <p>
        An example of timing comparison for §4.8 is plotted in the inset. In this example, the running time of the quadratic stiffened logarithmic barrier can increase by up to two orders of magnitude
        longer than ours during challenging moments. Note that the original IPC integrator manages this by running the Newton’s loop until exact convergence and solving the linear system via a direct
        solver in double precision, neither of which we employ. Hence, the issue should be less critical for CIPC.
      </p>
    </div>

    <!-- 5.2 -->
    <div class="trans">
      <h4>5.2 含弹性的刚度（Elasticity-Inclusive Stiffness）</h4>
      <p>
        为验证在接触刚度中加入<strong>弹性项</strong>的必要性，我们对单个圆柱做“含/不含该项”的扭转实验 <code>&lt;twist.mp4&gt;</code>。
        若不含该项，刚度仅依赖于<strong>平方反距离</strong>，接触间隙迅速逼近上限，系统整体刚度与碰撞概率上升， 视觉上表现为<strong>薄片厚度被低估</strong>。可通过引入 Li&nbsp;et&nbsp;al.&nbsp;[2021]
        的间隙偏置缓解，但运行时间会增加 7.3 倍。
      </p>
      <p>右侧内嵌图给出了（对数 y 轴的）接触间隙分布。</p>
    </div>
    <div class="fig">
      <img src="img/5_2_1.jpeg" alt="Figure 5.2.1: With/Without Elasticity-Inclusive Stiffness" class="internal_fig_img" />
      <img src="img/5_2_2.png" alt="Figure 5.2.2: With/Without Elasticity-Inclusive Stiffness" class="internal_fig_img" />
      <figcaption>内联图 5.2：含/不含弹性项的刚度对比与间隙分布</figcaption>
    </div>
    <div class="ori">
      <h4>5.2 Elasticity-Inclusive Stiffness</h4>
      <p>
        To validate the inclusion of an elasticity-involved term in the contact stiffness, we twisted a single cylinder with and without this term &lt;twist.mp4&gt;, thereby making the stiffness
        depend only on the squared inverse distance. Without it, the contact gap quickly approaches its limit, increasing the system stiffness and the chance of collisions. Visually, this manifests as
        an underestimated sheet thickness. One solution is to introduce offsetting to the gap [Li et al. 2021] as we did in the same video, but the runtime remains 7.3 times more expensive. The
        contact gap distribution (with the y-axis log-scaled) is visualized in the inset.
      </p>
    </div>

    <!-- 5.3 -->
    <div class="trans">
      <h4>5.3 牛顿步数（Number of Newton’s Steps）</h4>
      <p>
        为验证<strong>较少的牛顿步</strong>仍能得到视觉满意的结果，我们以最少 8 步模拟了图 1H（通常比未指定的
        <code>&lt;stack-8-newton.mp4&gt;</code> 用步数更多）。
      </p>
    </div>
    <div class="ori">
      <h4>5.3 Number of Newton’s Steps</h4>
      <p>
        To validate that a small number of Newton’s steps can still deliver visually satisfactory animations, we simulated Figure 1H with a minimum of eight Newton’s steps, which tends to use more
        steps than one unspecified &lt;stack-8-newton.mp4&gt;.
      </p>
    </div>

    <!-- 5.4 -->
    <div class="trans">
      <h4>5.4 二次能量函数（Quadratic Energy Function）</h4>
      <p>
        为验证三次能量的必要性，我们将 \(\psi_{\text{weak}}\) 替换为二次形式 \[ \psi_{\text{quad}}(g,\hat g,\kappa)= \begin{cases} \dfrac{\kappa}{2\hat g}\,(g-\hat g)^2, & g<\hat g,\\[6pt] 0, &
        \text{otherwise.} \end{cases} \] 该形式产生与我们同量级的力，但在 <code>&lt;drape.mp4&gt;</code> 中出现明显<strong>抖动伪影</strong>。 原因是虽在 \(g=\hat g\)
        处力连续，但<strong>搜索方向不连续</strong>；位置更新依赖搜索方向，而我们的牛顿迭代并不要求精确收敛。
      </p>
    </div>
    <div class="ori">
      <h4>5.4 Quadratic Energy Function</h4>
      <p>
        To validate the use of cubic energy, we have replaced \(\psi_{\text{weak}}\) with a quadratic counterpart \(\psi_{\text{quad}}(g,\hat g,\kappa)=\frac{\kappa}{2\hat g}(g-\hat g)^2\) if \(g<\hat
        g\) and 0 otherwise, which yields forces of the same order of magnitude as ours. This results in severe jitter artifacts, as seen in the inset &lt;drape.mp4&gt; because although the force is
        continuous at \(g=\hat g\), the search direction is not. The search direction is what matters for positional updates, and our Newton’s steps do not terminate at exact convergence.
      </p>
    </div>

    <!-- 5.5 -->
    <div class="trans">
      <h4>5.5 子步缩放牛顿法（Substep Scaled Newton’s Method）</h4>
      <p>
        为验证算法 1 的<strong>累计步长</strong>修正系数 \(\beta\) 的作用，我们对比了启用/禁用 \(\beta\) 的
        <code>&lt;squishy.mp4&gt;</code>（右图）。若不使用 \(\beta\)（即 \(\beta=1\)），会出现<strong>拖拽伪影</strong>。
      </p>
    </div>
    <div class="fig">
      <img src="img/5_5.jpeg" alt="Figure 5.5: Substep Scaling β" class="internal_fig_img" />
      <figcaption>内联图 5.5：是否启用 \(\beta\) 的对比</figcaption>
    </div>
    <div class="ori">
      <h4>5.5 Substep Scaled Newton’s Method</h4>
      <p>
        To validate our step size amendment \(\beta\) in Algorithm 1, we compare results with and without it &lt;squishy.mp4&gt; shown in the right inset. Without \(\beta\) (that is, setting
        \(\beta=1\)), the resulting animation exhibits dragging artifacts.
      </p>
    </div>

    <!-- 5.6 -->
    <div class="trans">
      <h4>5.6 应变限制的特征分析（Strain Limiting Eigenanalysis）</h4>
      <p>我们在补充材料中提供了可在 Google Colab 运行的简洁代码（<code>eigsys-1.py</code>），用于数值验证应变限制特征分析的正确性。</p>
    </div>
    <div class="ori">
      <h4>5.6 Strain Limiting Eigenanalysis</h4>
      <p>
        We provide a concise code in the supplementary material (eigsys-1.py) that runs on Google Colab to help readers numerically validate the correctness of our eigenanalysis of strain limiting.
      </p>
    </div>

    <!-- 5.7 -->
    <div class="trans">
      <h4>5.7 缓存矩阵组装（Cached Matrix Assembly）</h4>
      <p>
        使用“原味” CAMA [Tang et&nbsp;al.&nbsp;2016] 时，合并前的矩阵条目数量可比去重后<strong>多一到两个数量级</strong>。 右侧内嵌图给出了示例。对于数千万接触，这一点非常关键，否则 GPU 会耗尽显存。
      </p>
    </div>
    <div class="fig">
      <img src="img/5_7.png" alt="Figure 5.7: Cached Matrix Assembly" class="internal_fig_img" />
      <figcaption>内联图 5.7：使用/不使用缓存的条目与内存影响</figcaption>
    </div>
    <div class="ori">
      <h4>5.7 Cached Matrix Assembly</h4>
      <p>
        When a vanilla CAMA [Tang et al. 2016] is employed, the matrix entry counts before being merged can total to an order of magnitude greater than one being deduplicated. An example is shown in
        the right inset. For dozens of millions of contacts, this is important; otherwise, the GPU runs out of memory.
      </p>
    </div>

    <!-- 5.8 -->
    <div class="trans">
      <h4>5.8 可解析的摩擦接触（Resolved Frictional Contacts）</h4>
      <p>
        我们将一个盒子放在 30° 斜坡上 <code>&lt;friction-cube.mp4&gt;</code>：当 \(\mu&lt;0.5\) 会滑动，\(\mu&gt;0.5\) 则静止。 还投放了一个非平凡可变形体
        <code>&lt;friction-armadillo.mp4&gt;</code>：\(\mu=0.51\) 时它会滑行数秒后停止（可通过棋盘格图样验证静摩擦精度）。 两例均设牛顿步 32、\(\Delta t=10\) ms。
      </p>
    </div>
    <div class="ori">
      <h4>5.8 Resolved Frictional Contacts</h4>
      <p>
        We placed a box on a 30° tilted slope &lt;friction-cube.mp4&gt;. When \(\mu&lt;0.5\), the box slides but when \(\mu&gt;0.5\) it stays still. We also dropped a non-trivial deformable
        &lt;friction-armadillo.mp4&gt;. When \(\mu=0.51\) the armadillo slides down for several seconds but eventually stops as shown in the inset. For static friction, accuracy can be confirmed by
        closely examining the checkerboard pattern in the video. We set the Newton’s steps to 32 and \(\Delta t=10\) ms for the above two examples.
      </p>
    </div>

    <!-- 5.9 -->
    <div class="trans">
      <h4>5.9 纱线卷曲（Yarn Curl）</h4>
      <p>当接触与弹性<strong>共同求解</strong>时，已知“纱线式薄片”在拉伸下会卷曲，我们在 <code>&lt;yarn.mp4&gt;</code> 中验证了这一现象。</p>
    </div>
    <div class="ori">
      <h4>5.9 Yarn Curl</h4>
      <p>When contacts are resolved together with elasticity, it is known that a yarn-based sheet curls up when stretched. We confirmed this &lt;yarn.mp4&gt;.</p>
    </div>

    <!-- 5.10 -->
    <div class="trans">
      <h4>5.10 按顶点数的可扩展性曲线（Scalability Curve By Vertex Count）</h4>
      <p>我们对图 1H 做了<strong>分辨率递增</strong>实验 <code>&lt;scalability.mp4&gt;</code>，右图曲线显示：平均每帧时间与顶点数几乎<strong>线性</strong>相关。</p>
    </div>
    <div class="fig">
      <img src="img/5_10.png" alt="Figure 5.10: Scalability by Vertex Count" class="internal_fig_img" />
      <figcaption>内联图 5.10：随顶点数线性扩展的每帧用时</figcaption>
    </div>
    <div class="ori">
      <h4>5.10 Scalability Curve By Vertex Count</h4>
      <p>
        We have performed an example from Figure 1H with increasing resolutions &lt;scalability.mp4&gt;. An inset on the right shows the scalability curve, which is closely linear to the vertex count.
      </p>
    </div>

    <!-- 5.11 -->
    <div class="trans">
      <h4>5.11 免锁皱褶（Locking-Free Wrinkles）</h4>
      <p>
        当为防止拉伸而赋予<strong>高刚度</strong>时，薄片会“锁死”并产生僵硬皱褶；通常用<strong>应变限制</strong>修复。 我们在 <code>&lt;hang.mp4&gt;</code> 中确认了该现象（图中亦示 1%
        应变限制与不使用时的差异），强调应变限制对真实布料仿真的重要性。
      </p>
    </div>
    <div class="fig">
      <img src="img/5_11.jpeg" alt="Figure 5.11: Locking-Free Wrinkles & 1% Strain Limiting" class="internal_fig_img" />
      <figcaption>内联图 5.11：1% 应变限制下的免锁皱褶</figcaption>
    </div>
    <div class="ori">
      <h4>5.11 Locking-Free Wrinkles</h4>
      <p>
        Sheets are known to lock when a high stiffness is given to prevent stretch, leading to stiff-wrinkle artifacts, and strain limiting is often used to fix this. We have confirmed this in the
        right inset &lt;hang.mp4&gt;. This highlights the importance of strain limiting for realistic cloth simulation.
      </p>
    </div>

    <!-- 5.12 -->
    <div class="trans">
      <h4>5.12 风场动力学（Wind Dynamics）</h4>
      <p>在 <code>&lt;wind.mp4&gt;</code> 中，我们展示了非零环境风：5 张薄片周期性起皱并频繁与其它薄片发生“相吻”接触。</p>
    </div>
    <div class="ori">
      <h4>5.12 Wind Dynamics</h4>
      <p>An example of non-zero ambient wind is shown in &lt;wind.mp4&gt;. We confirm that five sheets flutter with periodic wrinkles that make frequent osculating contacts with other sheets.</p>
    </div>

    <!-- 5.13 -->
    <div class="trans">
      <h4>5.13 异维度接触（Mixed-Codimensional Contacts）</h4>
      <p>右侧内嵌 <code>&lt;codim.mp4&gt;</code> 展示了不同余维要素的混合场景：32 条杆与 167 万个四面体元素。 我们的方法无需特别处理即可自然应对这类情形。</p>
    </div>
    <div class="ori">
      <h4>5.13 Mixed-Codimensional Contacts</h4>
      <p>
        The right inset &lt;codim.mp4&gt; shows an example of different co-dimensional elements consisting of 32 rods and 1.67 million tetrahedral elements. Our method naturally handles such cases
        without special care.
      </p>
    </div>
    <!-- ============== 6 DISCUSSION AND LIMITATIONS ============== -->
    <div class="trans">
      <h3>6 讨论与局限（DISCUSSION AND LIMITATIONS）</h3>

      <p>
        <strong>精度（Accuracy）.</strong> 由于使用了近端投影（proximal projection），我们的方法会出现轻微波动，且无法像完全隐式方案那样到达“梯度趋零”的精确收敛点。
        如若需要精确收敛，可在牛顿步推进过程中逐步缩小搜索方向，做法类似模拟退火 [Henderson et al. 2003]。 在 <code>&lt;curtain.mp4&gt;</code> 中我们采用的收敛准则为 \(\lVert \mathbf{d}\rVert_\infty /
        \Delta t &lt; 10^{-2}\,\mathrm{m/s}\)， 其中 \(\mathbf{d}\) 是衰减前的搜索方向。位置以 \(\gamma\mathbf{d}\) 更新，\(\gamma\) 为衰减系数并由 \(\mathbf{d}\) 决定。 我们实验性地使用
        \(\gamma=\exp(-0.005\times \#\text{step})\)；这并非最优。 受限于单精度浮点，所能达到的精度低于 CIPC。
      </p>

      <p>
        <strong>摩擦（Friction）.</strong>
        仅用少量牛顿步无法得到准确的摩擦结果；若对此有要求，需要足够多的牛顿步（见 §4.6 与 §5.8）。 采用带颜色的 Gauss–Seidel 方法 [Chen et al. 2024; Fratarcangeli et al. 2016; Lan et al. 2023]
        并在每次访问顶点时更新摩擦势可能有帮助。 我们注意到：在存在<strong>静摩擦</strong>时，接触应表现得像“别针约束（pin）”。因此更大的步长更可取； 否则由于惯性势被刷新（遗忘了原 pin
        的位置）而产生的微小误差会在每一步累积，导致明显的摩擦接触漂移。 基于此，文中摩擦示例取 \(\Delta t=10\) ms。
      </p>

      <p>
        <strong>大质量差（Large Mass Differences）.</strong>
        由于我们依赖单精度的 CG 线性求解，当密度或刚度相差超过两个数量级时经验上会发散。 采用专门的预条件器（如 MAS [Wu et al. 2022]）或可缓解。
      </p>

      <p>
        <strong>误差回落步（Error Reduction Pass）.</strong> 我们在优化末尾加入了一个误差回落步，以确保力图最小化正确的总能量。 但其视觉改进在许多情况下较为细微；若更看重运行时间，可省略（示例见
        <code>&lt;stack-wo-err-red.mp4&gt;</code>）。
      </p>

      <p>
        <strong>用于接触的对数障碍（Logarithmic Barriers for Contact）.</strong> 在我们的示例里，配合“含弹性动态刚度”的对数障碍能成功解决接触，因为大多数间隙满足 \(g/\hat g &gt; 1/2\)。
        这并不意味着“搜索方向锁死”从不存在——例如 [Huang et al. 2024] 报告了仅基于距离的刚度会导致求解器发散。 我们还对三个<strong>无应变限制</strong>的示例进行了对比（披挂于球面 §5.4、圆柱扭转
        §5.2、以及 Fig.1H）， 在 <code>&lt;no-strain-limiting.mp4&gt;</code> 中列出了与对数障碍的耗时对比；三种情形在性能与视觉上几乎相同。
      </p>

      <table border="1" cellpadding="6" cellspacing="0">
        <thead>
          <tr>
            <th>案例</th>
            <th>三次障碍 Cubic (s)</th>
            <th>对数障碍 Log (s)</th>
            <th>差异 Diff (%)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>§5.4</td>
            <td>3.9</td>
            <td>4.0</td>
            <td>1.08</td>
          </tr>
          <tr>
            <td>§5.2</td>
            <td>44.3</td>
            <td>44.6</td>
            <td>0.30</td>
          </tr>
          <tr>
            <td>Fig.1H</td>
            <td>86.6</td>
            <td>85.6</td>
            <td>0.61</td>
          </tr>
        </tbody>
      </table>

      <p>因此我们认为：只有在<strong>存在应变限制</strong>时，三次障碍才体现出显著差异。</p>

      <p>
        <strong>步长（Step-Sizes）.</strong> §3.2 的“步长缩减的非精确牛顿法”在纯弹道（惯性主导）情况下能提供较好的初始猜测，而在惯性势不占主导时则较差。
        这意味着当步长较大时，初始猜测会变差——与系统是否可逆无关。例如 \(\Delta t=100\) ms 时画面会变“僵硬”， 可见 <code>&lt;curtain-01-dt.mp4&gt;</code>。经验上，除摩擦接触外，\(\Delta t\) 在 1–10 ms
        往往能在精度与性能间取得较好平衡。 该问题是我们方法特有的，CIPC 中不存在。
      </p>
    </div>

    <div class="ori">
      <h3>6 DISCUSSION AND LIMITATIONS</h3>

      <p>
        <strong>Accuracy.</strong>
        Due to the proximal projection, our method exhibits minor fluctuations and does not reach the gradient-vanishing point as precisely as fully implicit schemes. If this is important, one could
        achieve exact convergence by gradually diminishing the search directions as Newton’s steps continue, similar to simulated annealing [Henderson et al. 2003], as we did in &lt;curtain.mp4&gt;
        with a convergence criterion \(\lVert \mathbf{d}\rVert_\infty / \Delta t &lt; 10^{-2}\,\mathrm{m/s}\), where \(\mathbf{d}\) is the search direction before being diminished. Positions are
        updated by \(\gamma\mathbf{d}\) with a diminishing coefficient \(\gamma\), and termination is decided by \(\mathbf{d}\). We used \(\gamma=\exp(-0.005\times \#\text{step})\); this is
        experimental and not optimal. Due to single-precision floating points, our achievable accuracy is lower than that of CIPC.
      </p>

      <p>
        <strong>Friction.</strong>
        Our method does not resolve accurate friction with only a few Newton’s steps. If this is important, running a sufficient number of Newton’s steps is necessary, as we did in §4.6 and §5.8.
        Employing a colored Gauss–Seidel method [Chen et al. 2024; Fratarcangeli et al. 2016; Lan et al. 2023] and updating the friction potential every time a vertex is visited may help. When static
        friction is present, a contact should behave like a pin constraint. Hence larger time steps are preferable; otherwise, inaccuracies (mostly due to refreshing the inertial potential) accumulate
        and cause noticeable frictional contact drift. We chose \(\Delta t=10\) ms for our frictional contact examples.
      </p>

      <p>
        <strong>Large Mass Differences.</strong>
        Since we depend on a single-precision CG to invert the system, we empirically find divergence when more than two orders of magnitude differences in density or stiffness are involved. A
        dedicated preconditioner, such as MAS [Wu et al. 2022], may help.
      </p>

      <p>
        <strong>Error Reduction Pass.</strong>
        We included an error reduction pass at the end to ensure that we aim to minimize the correct total energy. However, visual improvements are subtle in many cases; thus this step can be omitted
        for faster runtime (see &lt;stack-wo-err-red.mp4&gt;).
      </p>

      <p>
        <strong>Logarithmic Barriers for Contact.</strong>
        In our examples, logarithmic barriers with our elasticity-inclusive dynamic stiffness resolve contacts without failure because most gaps remain \(g/\hat g &gt; 1/2\). This does not mean search
        direction locking is never an issue; e.g., [Huang et al. 2024] report divergence for purely distance-based stiffness. We also ran three examples without strain limiting—draping sheets on a
        sphere (§5.4), cylinder twisting (§5.2), and Fig.1H—and compared our cubic and logarithmic barriers (&lt;no-strain-limiting.mp4&gt;). The numbers denote time per video frame. We observed
        nearly identical results both in performance and visually.
      </p>

      <table border="1" cellpadding="6" cellspacing="0">
        <thead>
          <tr>
            <th>Cubic (s)</th>
            <th>Log (s)</th>
            <th>Diff (%)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>3.9</td>
            <td>4.0</td>
            <td>1.08</td>
          </tr>
          <tr>
            <td>44.3</td>
            <td>44.6</td>
            <td>0.30</td>
          </tr>
          <tr>
            <td>86.6</td>
            <td>85.6</td>
            <td>0.61</td>
          </tr>
        </tbody>
      </table>

      <p>Therefore, we conclude that our cubic barrier makes a difference only when strain limiting is present.</p>

      <p>
        <strong>Step-Sizes.</strong>
        Our step-size reduced inexact Newton’s method in §3.2 provides the best initial guess for purely ballistic motion and a poor guess when the inertia potential is not dominant. This implies our
        initial guess becomes less accurate when a large step is chosen, regardless of system invertibility. For example, with \(\Delta t=100\) ms the animation tends to become stiffened
        (&lt;curtain-01-dt.mp4&gt;). Empirically, a step size around 1–10 ms provides a good balance between accuracy and performance for many examples, except frictional contacts. This issue is
        specific to our method and does not exist in CIPC.
      </p>
    </div>

    <!-- ============== 7 CONCLUSIONS ============== -->
    <div class="trans">
      <h3>7 结论（CONCLUSIONS）</h3>
      <p>
        我们聚焦于使用障碍项处理<strong>不等式约束</strong>。方法以 IPC 为基础，但提出了新的<strong>三次能量</strong>与
        <strong>含弹性的动态刚度</strong>，并在时间积分上采用投影式交替。 该方法同时应用于接触与应变限制，使布料仿真在高刚度下仍能<strong>无锁死</strong>。
        我们通过压力测试以及与对数/二次障碍的对比验证了方法的有效性。
      </p>
    </div>

    <div class="ori">
      <h3>7 CONCLUSIONS</h3>
      <p>
        We focused on inequality constraints using barriers. Our method is based on IPC but diverges by devising a new cubic energy and a dynamic elasticity-inclusive stiffness, and opting for
        projective alternation for time integration. We applied our method to both contacts and strain limiting, which enables locking-free cloth simulation. We validated our method through stress
        tests and comparisons to logarithmic and quadratic barrier counterparts.
      </p>
    </div>
    <!-- ============== ACKNOWLEDGMENTS ============== -->
    <div class="trans">
      <h3>致谢（ACKNOWLEDGMENTS）</h3>
      <p>
        作者感谢匿名审稿人提供的详尽反馈与有益意见，这些建议显著提升了本文质量。作者亦感谢 Nobuyuki Umetani 在有限元方法方面分享的专业知识，以及 Ken Hayami 就共轭梯度法收敛性的
        富有洞见的讨论。最后，作者感谢 ZOZO, Inc. 允许其将本课题作为主要工作内容的一部分来开展。 同时也感谢公司知识产权部门的各团队，准许我们发表技术成果与发布代码；并感谢为出版流程
        所需内部手续提供协助的诸多同事。
      </p>
    </div>
    <div class="ori">
      <h3>ACKNOWLEDGMENTS</h3>
      <p>
        The author thanks the anonymous reviewers for their detailed feedback and helpful comments, which significantly improved the paper. The author also thanks Nobuyuki Umetani for sharing his
        expertise in the Finite Element Method and Ken Hayami for insightful discussions on the convergence of the conjugate gradient method. Finally, the author would like to thank ZOZO, Inc. for
        allowing him to work on this topic as part of his main workload. The author also extends thanks to the teams in the IP department for permitting the publication of our technical work and the
        release of our code, as well as to many others for assisting with the internal paperwork required for publication.
      </p>
    </div>
    <!-- ============== REFERENCES (title only translated) ============== -->
    <div class="trans">
      <h3>参考文献（REFERENCES）</h3>
    </div>
    <div class="ori">
      <p>
        Jérémie Allard, François Faure, Hadrien Courtecuisse, Florent Falipou, Christian Duriez, and Paul G. Kry. 2010. Volume Contact Constraints at Arbitrary Resolution.
        <em>ACM Trans. Graph.</em> 29, 4, Article 82 (July 2010), 10 pages. https://doi.org/10.1145/1778765.1778819
      </p>

      <p>
        Sheldon Andrews, Kenny Erleben, and Zachary Ferguson. 2022. Contact and Friction Simulation for Computer Graphics. In <em>ACM SIGGRAPH 2022 Courses</em> (Vancouver, British Columbia, Canada)
        (SIGGRAPH ’22). Association for Computing Machinery, New York, NY, USA, Article 3, 172 pages. https://doi.org/10.1145/3532720.3535640
      </p>

      <p>
        David Baraff and Andrew Witkin. 1998. Large Steps in Cloth Simulation. In <em>Proceedings of the 25th Annual Conference on Computer Graphics and Interactive Techniques</em> (SIGGRAPH ’98).
        Association for Computing Machinery, New York, NY, USA, 43–54. https://doi.org/10.1145/280814.280821
      </p>

      <p>David Baraff, Andrew Witkin, and Michael Kass. 2003. Untangling Cloth. <em>ACM Trans. Graph.</em> 22, 3 (July 2003), 862–870. https://doi.org/10.1145/882262.882357</p>

      <p>
        Sofien Bouaziz, Sebastian Martin, Tiantian Liu, Ladislav Kavan, and Mark Pauly. 2014. Projective Dynamics: Fusing Constraint Projections for Fast Simulation. <em>ACM Trans. Graph.</em> 33, 4,
        Article 154 (July 2014), 11 pages. https://doi.org/10.1145/2601097.2601116
      </p>

      <p>
        Robert Bridson, Ronald Fedkiw, and John Anderson. 2002. Robust Treatment of Collisions, Contact and Friction for Cloth Animation. <em>ACM Trans. Graph.</em> 21, 3 (July 2002), 594–603.
        https://doi.org/10.1145/566654.566623
      </p>

      <p>
        Tyson Brochu, Essex Edwards, and Robert Bridson. 2012. Efficient Geometrically Exact Continuous Collision Detection. <em>ACM Trans. Graph.</em> 31, 4, Article 96 (July 2012), 7 pages.
        https://doi.org/10.1145/2185520.2185592
      </p>

      <p>
        Thomas Buffet, Damien Rohmer, Loïc Barthe, Laurence Boissieux, and Marie-Paule Cani. 2019. Implicit Untangling: A Robust Solution for Modeling Layered Clothing. <em>ACM Trans. Graph.</em> 38,
        4, Article 120 (July 2019), 12 pages. https://doi.org/10.1145/3306346.3323010
      </p>

      <p>Anka He Chen, Ziheng Liu, Yang Yin, and Cem Yuksel. 2024. Vertex Block Descent. <em>ACM Transactions on Graphics (TOG)</em> 116 (2024).</p>

      <p>
        He Chen, Elie Diaz, and Cem Yuksel. 2023. Shortest Path to Boundary for Self-Intersecting Meshes. <em>ACM Trans. Graph.</em> 42, 4, Article 146 (July 2023), 15 pages.
        https://doi.org/10.1145/3592136
      </p>

      <p>
        Renjie Chen and Ofir Weber. 2017. GPU-Accelerated Locally Injective Shape Deformation. <em>ACM Trans. Graph.</em> 36, 6, Article 214 (November 2017), 13 pages.
        https://doi.org/10.1145/3130800.3130843
      </p>

      <p>
        Yunuo Chen, Minchen Li, Lei Lan, Hao Su, Yin Yang, and Chenfanfu Jiang. 2022. A Unified Newton Barrier Method for Multibody Dynamics. <em>ACM Trans. Graph.</em> 41, 4, Article 66 (July 2022),
        14 pages. https://doi.org/10.1145/3528223.3530076
      </p>

      <p>
        Franz Chouly, Mathieu Fabre, Patrick Hild, Rabii Mlika, Jérôme Pousin, and Yves Renard. 2017. An Overview of Recent Results on Nitsche’s Method for Contact Problems. In
        <em>Geometrically Unfitted Finite Element Methods and Applications</em>, Stéphane P. A. Bordas, Erik Burman, Mats G. Larson, and Maxim A. Olshanskii (Eds.). Springer International Publishing,
        Cham, 93–141.
      </p>

      <p>
        Franz Chouly, Patrick Hild, Vanessa Lleras, and Yves Renard. 2022. Nitsche method for contact with Coulomb friction: Existence results for the static and dynamic finite element formulations.
        <em>J. Comput. Appl. Math.</em> 416 (2022), 114557. https://doi.org/10.1016/j.cam.2022.114557
      </p>

      <p>
        Gabriel Cirio, Jorge Lopez-Moreno, David Miraut, and Miguel A. Otaduy. 2014. Yarn-Level Simulation of Woven Cloth. <em>ACM Trans. Graph.</em> 33, 6, Article 207 (November 2014), 11 pages.
        https://doi.org/10.1145/2661229.2661279
      </p>

      <p>
        Gabriel Cirio, Jorge Lopez-Moreno, and Miguel A. Otaduy. 2017. Yarn-Level Cloth Simulation with Sliding Persistent Contacts. <em>IEEE Trans. Vis. Comput. Graph.</em> 23, 2 (2017), 1152–1162.
        https://doi.org/10.1109/TVCG.2016.2592908
      </p>

      <p>Shane Cook. 2012. <em>CUDA Programming: A Developer’s Guide to Parallel Computing with GPUs</em> (1st ed.). Morgan Kaufmann Publishers Inc., San Francisco, CA, USA.</p>

      <p>
        Gilles Daviet, Florence Bertails-Descoubes, and Laurence Boissieux. 2011. A Hybrid Iterative Solver for Robustly Capturing Coulomb Friction in Hair Dynamics. <em>ACM Trans. Graph.</em> 30, 6
        (December 2011), 1–12. https://doi.org/10.1145/2070781.2024173
      </p>

      <p>Kenny Erleben. 2004. Stable, Robust, and Versatile Multibody Dynamics Animation. Ph.D. Dissertation. University of Copenhagen.</p>

      <p>
        François Faure, Sébastien Barbier, Jérémie Allard, and Florent Falipou. 2008. Image-Based Collision Detection and Response between Arbitrary Volume Objects. In
        <em>Proceedings of the 2008 ACM SIGGRAPH/Eurographics Symposium on Computer Animation</em> (Dublin, Ireland) (SCA ’08). Eurographics Association, Goslar, DEU, 155–162.
      </p>

      <p>
        Xudong Feng, Huamin Wang, Yin Yang, and Weiwei Xu. 2024. Neural-Assisted Homogenization of Yarn-Level Cloth. In <em>ACM SIGGRAPH 2024 Conference Papers</em> (Denver, CO, USA) (SIGGRAPH ’24).
        Association for Computing Machinery, New York, NY, USA, Article 80, 10 pages. https://doi.org/10.1145/3641519.3657411
      </p>

      <p>
        Marco Fratarcangeli, Valentina Tibaldo, and Fabio Pellacini. 2016. Vivace: A Practical Gauss-Seidel Method for Stable Soft Body Dynamics. <em>ACM Trans. Graph.</em> 35, 6, Article 214
        (November 2016), 9 pages. https://doi.org/10.1145/2980179.2982437
      </p>

      <p>
        Rony Goldenthal, David Harmon, Raanan Fattal, Michel Bercovier, and Eitan Grinspun. 2007. Efficient Simulation of Inextensible Cloth. <em>ACM Trans. Graph.</em> 26, 3 (July 2007), 49–es.
        https://doi.org/10.1145/1276377.1276438
      </p>

      <p>
        M. Griebel and M. A. Schweitzer. 2003. A Particle-Partition of Unity Method Part V: Boundary Conditions. Springer Berlin Heidelberg, Berlin, Heidelberg, 519–542.
        https://doi.org/10.1007/978-3-642-55627-2_27
      </p>

      <p>
        Eitan Grinspun, Anil N. Hirani, Mathieu Desbrun, and Peter Schröder. 2003. Discrete Shells. In <em>Proceedings of the 2003 ACM SIGGRAPH/Eurographics Symposium on Computer Animation</em> (San
        Diego, California) (SCA ’03). Eurographics Association, Goslar, DEU, 62–67.
      </p>

      <p>Gaël Guennebaud, Benoît Jacob, et al. 2010. Eigen v3. http://eigen.tuxfamily.org.</p>

      <p>Tom Gustafsson, Rolf Stenberg, and Juha Videman. 2020. On Nitsche’s method for elastic contact problems. arXiv:1902.09312 [math.NA]</p>

      <p>
        David Harmon, Etienne Vouga, Breannan Smith, Rasmus Tamstorf, and Eitan Grinspun. 2009. Asynchronous Contact Mechanics. <em>ACM Trans. Graph.</em> 28, 3, Article 87 (July 2009), 12 pages.
        https://doi.org/10.1145/1531326.1531393
      </p>

      <p>
        David Harmon, Etienne Vouga, Rasmus Tamstorf, and Eitan Grinspun. 2008. Robust Treatment of Simultaneous Collisions. <em>ACM Trans. Graph.</em> 27, 3 (August 2008), 1–4.
        https://doi.org/10.1145/1360612.1360622
      </p>

      <p>
        Darrall Henderson, Sheldon H. Jacobson, and Alan W. Johnson. 2003. The theory and practice of simulated annealing. <em>Internat. Ser. Oper. Res. Management Sci.</em>, Vol. 57. Kluwer Acad.
        Publ., Boston, MA, 287–319. https://doi.org/10.1007/0-306-48056-5_10
      </p>

      <p>Kemeng Huang, Floyd Chitalu, Huancheng Lin, and Taku Komura. 2024. GIPC: Fast and stable Gauss-Newton optimization of IPC barrier energy. arXiv:2308.09400 [cs.GR]</p>

      <p>
        S. Huh, D. N. Metaxas, and N. I. Badler. 2001. Collision resolutions in cloth simulation. In <em>Proceedings Computer Animation 2001. Fourteenth Conference on Computer Animation</em> (Cat.
        No.01TH8596). 122–127. https://doi.org/10.1109/CA.2001.982385
      </p>

      <p>
        Ning Jin, Wenlong Lu, Zhenglin Geng, and Ronald P. Fedkiw. 2017. Inequality Cloth. In <em>Proceedings of the ACM SIGGRAPH / Eurographics Symposium on Computer Animation</em> (Los Angeles,
        California) (SCA ’17). Association for Computing Machinery, New York, NY, USA, Article 16, 10 pages. https://doi.org/10.1145/3099564.3099568
      </p>

      <p>
        Jonathan M. Kaldor, Doug L. James, and Steve Marschner. 2008. Simulating Knitted Cloth at the Yarn Level. <em>ACM Trans. Graph.</em> 27, 3 (August 2008), 1–9.
        https://doi.org/10.1145/1360612.1360664
      </p>

      <p>
        Jonathan M. Kaldor, Doug L. James, and Steve Marschner. 2010. Efficient Yarn-Based Cloth with Adaptive Contact Linearization. <em>ACM Trans. Graph.</em> 29, 4, Article 105 (July 2010), 10
        pages. https://doi.org/10.1145/1778765.1778842
      </p>

      <p>
        Danny M. Kaufman, Timothy Edmunds, and Dinesh K. Pai. 2005. Fast Frictional Dynamics for Rigid Bodies. <em>ACM Trans. Graph.</em> 24, 3 (July 2005), 946–956.
        https://doi.org/10.1145/1073204.1073295
      </p>

      <p>
        Danny M. Kaufman, Shinjiro Sueda, Doug L. James, and Dinesh K. Pai. 2008. Staggered Projections for Frictional Contact in Multibody Systems. <em>ACM Trans. Graph.</em> 27, 5, Article 164
        (December 2008), 11 pages. https://doi.org/10.1145/1409060.1409117
      </p>

      <p>Theodore Kim. 2020. A Finite Element Formulation of Baraff-Witkin Cloth. Eurographics Association, Goslar, DEU. https://doi.org/10.1111/cgf.14111</p>

      <p>
        Theodore Kim and David Eberle. 2022. Dynamic Deformables: Implementation and Production Practicalities (Now with Code!). In <em>ACM SIGGRAPH 2022 Courses</em> (Vancouver, British Columbia,
        Canada) (SIGGRAPH ’22). Association for Computing Machinery, New York, NY, USA, Article 7, 259 pages. https://doi.org/10.1145/3532720.3535628
      </p>

      <p>
        Tae-Yong Kim, Nuttapong Chentanez, and Matthias Müller-Fischer. 2012. Long Range Attachments – a Method to Simulate Inextensible Clothing in Computer Games. In
        <em>Proceedings of the ACM SIGGRAPH/Eurographics Symposium on Computer Animation</em> (Lausanne, Switzerland) (SCA ’12). Eurographics Association, Goslar, DEU, 305–310.
      </p>

      <p>
        Lei Lan, Minchen Li, Chenfanfu Jiang, Huamin Wang, and Yin Yang. 2023. Second-Order Stencil Descent for Interior-Point Hyperelasticity. <em>ACM Trans. Graph.</em> 42, 4, Article 108 (July
        2023), 16 pages. https://doi.org/10.1145/3592104
      </p>

      <p>
        Lei Lan, Guanqun Ma, Yin Yang, Changxi Zheng, Minchen Li, and Chenfanfu Jiang. 2022. Penetration-Free Projective Dynamics on the GPU. <em>ACM Trans. Graph.</em> 41, 4, Article 69 (July 2022),
        16 pages. https://doi.org/10.1145/3528223.3530069
      </p>

      <p>
        Dohae Lee, Hyun Kang, and In-Kwon Lee. 2023. ClothCombo: Modeling Inter-Cloth Interaction for Draping Multi-Layered Clothes. <em>ACM Trans. Graph.</em> 42, 6, Article 247 (December 2023), 13
        pages. https://doi.org/10.1145/3618376
      </p>

      <p>Chris Lewin. 2018. Cloth Self Collision with Predictive Contacts. https://api.semanticscholar.org/CorpusID:202704112</p>

      <p>
        Minchen Li, Zachary Ferguson, Teseo Schneider, Timothy Langlois, Denis Zorin, Daniele Panozzo, Chenfanfu Jiang, and Danny M. Kaufman. 2020. Incremental Potential Contact: Intersection- and
        Inversion-free Large Deformation Dynamics. <em>ACM Trans. Graph.</em> (SIGGRAPH) 39, 4, Article 49 (2020).
      </p>

      <p>Minchen Li, Danny M. Kaufman, and Chenfanfu Jiang. 2021. Codimensional Incremental Potential Contact. <em>ACM Trans. Graph.</em> (SIGGRAPH) 40, 4, Article 170 (2021).</p>

      <p>
        Huancheng Lin, Floyd M. Chitalu, and Taku Komura. 2022. Isotropic ARAP Energy Using Cauchy-Green Invariants. <em>ACM Trans. Graph.</em> 41, 6, Article 275 (November 2022), 14 pages.
        https://doi.org/10.1145/3550454.3555507
      </p>

      <p>
        Tiantian Liu, Adam W. Bargteil, James F. O’Brien, and Ladislav Kavan. 2013. Fast Simulation of Mass-Spring Systems. <em>ACM Trans. Graph.</em> 32, 6, Article 214 (November 2013), 7 pages.
        https://doi.org/10.1145/2508363.2508406
      </p>

      <p>
        M. Macklin, K. Erleben, M. Müller, N. Chentanez, S. Jeschke, and T. Y. Kim. 2020. Primal/Dual Descent Methods for Dynamics. Eurographics Association, Goslar, DEU.
        https://doi.org/10.1111/cgf.14104
      </p>

      <p>
        Miles Macklin, Matthias Müller, and Nuttapong Chentanez. 2016. XPBD: Position-Based Simulation of Compliant Constrained Dynamics. In
        <em>Proceedings of the 9th International Conference on Motion in Games</em> (Burlingame, California) (MIG ’16). Association for Computing Machinery, New York, NY, USA, 49–54.
        https://doi.org/10.1145/2994258.2994272
      </p>

      <p>
        Sebastian Martin, Bernhard Thomaszewski, Eitan Grinspun, and Markus Gross. 2011. Example-Based Elastic Materials. <em>ACM Trans. Graph.</em> 30, 4, Article 72 (July 2011), 8 pages.
        https://doi.org/10.1145/2010324.1964967
      </p>

      <p>Nicholas D. Matsakis and Felix S. Klock. 2014. The Rust Language. <em>Ada Lett.</em> 34, 3 (October 2014), 103–104. https://doi.org/10.1145/2692956.2663188</p>

      <p>
        Aleka McAdams, Yongning Zhu, Andrew Selle, Mark Empey, Rasmus Tamstorf, Joseph Teran, and Eftychios Sifakis. 2011. Efficient Elasticity for Character Skinning with Contact and Collisions.
        <em>ACM Trans. Graph.</em> 30, 4, Article 37 (July 2011), 12 pages. https://doi.org/10.1145/2010324.1964932
      </p>

      <p>
        Tomas Möller and Ben Trumbore. 2005. Fast, minimum storage ray/triangle intersection. In <em>ACM SIGGRAPH 2005 Courses</em> (Los Angeles, California) (SIGGRAPH ’05). Association for Computing
        Machinery, New York, NY, USA, 7–es. https://doi.org/10.1145/1198555.1198746
      </p>

      <p>
        Matthias Müller, Bruno Heidelberger, Marcus Hennix, and John Ratcliff. 2007. Position based dynamics. <em>Journal of Visual Communication and Image Representation</em> 18, 2 (2007), 109–118.
        https://doi.org/10.1016/j.jvcir.2007.01.005
      </p>

      <p>
        Matthias Müller, Tae-Yong Kim, and Nuttapong Chentanez. 2012. Fast Simulation of Inextensible Hair and Fur. In <em>Workshop on Virtual Reality Interaction and Physical Simulation</em>, Jan
        Bender, Arjan Kuijper, Dieter W. Fellner, and Eric Guerin (Eds.). The Eurographics Association. https://doi.org/10.2312/PE/vriphys/vriphys12/039-044
      </p>

      <p>
        Matthew Overby, George E. Brown, Jie Li, and Rahul Narain. 2017. ADMM ⊇ Projective Dynamics: Fast Simulation of Hyperelastic Models with Dynamic Constraints.
        <em>IEEE Trans. Vis. Comput. Graph.</em> 23, 10 (2017), 2222–2234. https://doi.org/10.1109/TVCG.2017.2730875
      </p>

      <p>Julian Panetta. 2020. Analytic Eigensystems for Isotropic Membrane Energies. arXiv:2008.10698 [math.NA]</p>

      <p>
        Xavier Provot. 1997. Collision and self-collision handling in cloth model dedicated to design garments. In <em>Eurographics</em>. Springer Vienna, 177–189.
        https://doi.org/10.1007/978-3-7091-6874-5_13
      </p>

      <p>
        Jessica D. Sanders, John E. Dolbow, and Tod A. Laursen. 2009. On methods for stabilizing constraints over enriched interfaces in elasticity. <em>Internat. J. Numer. Methods Engrg.</em> 78, 9
        (2009), 1009–1036. https://doi.org/10.1002/nme.2514 arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1002/nme.2514
      </p>

      <p>
        H. Schmidl and V. J. Milenkovic. 2004. A fast impulsive contact suite for rigid body simulation. <em>IEEE Transactions on Visualization and Computer Graphics</em> 10, 2 (2004), 189–197.
        https://doi.org/10.1109/TVCG.2004.1260770
      </p>

      <p>
        Xing Shen, Runyuan Cai, Mengxiao Bi, and Tangjie Lv. 2024. Preconditioned Nonlinear Conjugate Gradient Method for Real-time Interior-point Hyperelasticity. In
        <em>ACM SIGGRAPH 2024 Conference Papers</em> (Denver, CO, USA) (SIGGRAPH ’24). Association for Computing Machinery, New York, NY, USA, Article 96, 11 pages.
        https://doi.org/10.1145/3641519.3657490
      </p>

      <p>
        Zhongwei Shen, Jin Huang, Wei Chen, and Hujun Bao. 2015. Geometrically Exact Simulation of Inextensible Ribbon. <em>Computer Graphics Forum</em> 34, 7 (2015), 145–154.
        https://doi.org/10.1111/cgf.12753 arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1111/cgf.12753
      </p>

      <p>
        Alvin Shi and Theodore Kim. 2023. A Unified Analysis of Penalty-Based Collision Energies. <em>Proc. ACM Comput. Graph. Interact. Tech.</em> 6, 3, Article 41 (Aug 2023), 19 pages.
        https://doi.org/10.1145/3606934
      </p>

      <p>
        Breannan Smith, Fernando De Goes, and Theodore Kim. 2018. Stable Neo-Hookean Flesh Simulation. <em>ACM Trans. Graph.</em> 37, 2, Article 12 (March 2018), 15 pages.
        https://doi.org/10.1145/3180491
      </p>

      <p>
        Georg Sperl, Rahul Narain, and Chris Wojtan. 2020. Homogenized Yarn-Level Cloth. <em>ACM Trans. Graph.</em> 39, 4, Article 48 (July 2020), 16 pages. https://doi.org/10.1145/3386569.3392412
      </p>

      <p>
        Georg Sperl, Rahul Narain, and Chris Wojtan. 2021. Mechanics-Aware Deformation of Yarn Pattern Geometry. <em>ACM Trans. Graph.</em> 40, 4, Article 168 (July 2021), 11 pages.
        https://doi.org/10.1145/3450626.3459816
      </p>

      <p>
        Alexey Stomakhin, Russell Howes, Craig Schroeder, and Joseph M. Teran. 2012. Energetically Consistent Invertible Elasticity. In
        <em>Proceedings of the ACM SIGGRAPH/Eurographics Symposium on Computer Animation</em> (Lausanne, Switzerland) (SCA ’12). Eurographics Association, Goslar, DEU, 25–32.
      </p>

      <p>
        Alexey Stomakhin, Craig Schroeder, Lawrence Chai, Joseph Teran, and Andrew Selle. 2013. A Material Point Method for Snow Simulation. <em>ACM Trans. Graph.</em> 32, 4, Article 102 (July 2013),
        10 pages. https://doi.org/10.1145/2461912.2461948
      </p>

      <p>
        Shinjiro Sueda, Garrett L. Jones, David I. W. Levin, and Dinesh K. Pai. 2011. Large-Scale Dynamic Simulation of Highly Constrained Strands. <em>ACM Trans. Graph.</em> 30, 4, Article 39 (July
        2011), 10 pages. https://doi.org/10.1145/2010324.1964934
      </p>

      <p>
        Tetsuya Takahashi and Christopher Batty. 2021. FrictionalMonolith: A Monolithic Optimization-Based Approach for Granular Flow with Contact-Aware Rigid-Body Coupling.
        <em>ACM Trans. Graph.</em> 40, 6, Article 206 (Dec 2021), 20 pages. https://doi.org/10.1145/3478513.3480539
      </p>

      <p>
        Tetsuya Takahashi and Christopher Batty. 2022. ElastoMonolith: A Monolithic Optimization-Based Liquid Solver for Contact-Aware Elastic-Solid Coupling. <em>ACM Trans. Graph.</em> 41, 6, Article
        255 (Nov 2022), 19 pages. https://doi.org/10.1145/3550454.3555474
      </p>

      <p>
        Min Tang, Dinesh Manocha, Miguel A. Otaduy, and Ruofeng Tong. 2012. Continuous Penalty Forces. <em>ACM Trans. Graph.</em> 31, 4, Article 107 (Jul 2012), 9 pages.
        https://doi.org/10.1145/2185520.2185603
      </p>

      <p>
        Min Tang, Huamin Wang, Le Tang, Ruofeng Tong, and Dinesh Manocha. 2016. CAMA: Contact-Aware Matrix Assembly with Unified Collision Handling for GPU-based Cloth Simulation.
        <em>Computer Graphics Forum</em> 35, 2 (2016), 511–521. https://doi.org/10.1111/cgf.12851 arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1111/cgf.12851
      </p>

      <p>
        Min Tang, tongtong wang, Zhongyuan Liu, Ruofeng Tong, and Dinesh Manocha. 2018. ICloth: Incremental Collision Handling for GPU-Based Interactive Cloth Simulation. 37, 6, Article 204 (December
        2018), 10 pages. https://doi.org/10.1145/3272127.3275005
      </p>

      <p>
        Bernhard Thomaszewski, Simon Pabst, and Wolfgang Straßer. 2009. Continuum-based Strain Limiting. <em>Computer Graphics Forum</em> 28, 2 (2009), 569–576.
        https://doi.org/10.1111/j.1467-8659.2009.01397.x arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1111/j.1467-8659.2009.01397.x
      </p>

      <p>
        Robin Tomcin, Dominik Sibbing, and Leif Kobbelt. 2014. Efficient enforcement of hard articulation constraints in the presence of closed loops and contacts. <em>Computer Graphics Forum</em> 33,
        2 (2014), 235–244. https://doi.org/10.1111/cgf.12322 arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1111/cgf.12322
      </p>

      <p>
        Mickeal Verschoor and Andrei C. Jalba. 2019. Efficient and Accurate Collision Response for Elastically Deformable Models. <em>ACM Trans. Graph.</em> 38, 2, Article 17 (March 2019), 20 pages.
        https://doi.org/10.1145/3209887
      </p>

      <p>
        Pascal Volino and Nadia Magnenat-Thalmann. 2006. Resolving Surface Collisions through Intersection Contour Minimization. <em>ACM Trans. Graph.</em> 25, 3 (July 2006), 1154–1159.
        https://doi.org/10.1145/1141911.1142007
      </p>

      <p>
        Bolun Wang, Zachary Ferguson, Xin Jiang, Marco Attene, Daniele Panozzo, and Teseo Schneider. 2022. Fast and Exact Root Parity for Continuous Collision Detection.
        <em>Computer Graphics Forum</em> 41, 2 (2022), 355–363. https://doi.org/10.1111/cgf.14479 arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1111/cgf.14479
      </p>

      <p>
        Bolun Wang, Zachary Ferguson, Teseo Schneider, Xin Jiang, Marco Attene, and Daniele Panozzo. 2021. A Large Scale Benchmark and an Inclusion-Based Algorithm for Continuous Collision Detection.
        <em>ACM Transactions on Graphics</em> 40, 5, Article 188 (Oct. 2021), 16 pages.
      </p>

      <p>Huamin Wang. 2014. Defending Continuous Collision Detection against Errors. <em>ACM Trans. Graph.</em> 33, 4, Article 122 (July 2014), 10 pages. https://doi.org/10.1145/2601097.2601114</p>

      <p>
        Huamin Wang, James O’Brien, and Ravi Ramamoorthi. 2010. Multi-Resolution Isotropic Strain Limiting. <em>ACM Trans. Graph.</em> 29, 6, Article 156 (December 2010), 10 pages.
        https://doi.org/10.1145/1882261.1866182
      </p>

      <p>
        Tianyu Wang, Jiong Chen, Dongping Li, Xiaowei Liu, Huamin Wang, and Kun Zhou. 2023. Fast GPU-Based Two-Way Continuous Collision Handling. <em>ACM Trans. Graph.</em> 42, 5, Article 167 (Jul
        2023), 15 pages. https://doi.org/10.1145/3604551
      </p>

      <p>
        Jungdam Won and Jehee Lee. 2019. Learning Body Shape Variation in Physics-Based Characters. <em>ACM Trans. Graph.</em> 38, 6, Article 207 (November 2019), 12 pages.
        https://doi.org/10.1145/3355089.3356499
      </p>

      <p>
        Botao Wu, Zhendong Wang, and Huamin Wang. 2022. A GPU-Based Multilevel Additive Schwarz Preconditioner for Cloth and Deformable Body Simulation. <em>ACM Trans. Graph.</em> 41, 4, Article 63
        (Jul 2022), 14 pages. https://doi.org/10.1145/3528223.3530085
      </p>

      <p>
        Longhua Wu, Botao Wu, Yin Yang, and Huamin Wang. 2020. A Safe and Fast Repulsion Method for GPU-based Cloth Self Collisions. <em>ACM Trans. Graph.</em> 40, 1 (2020), 5:1–5:18.
        https://doi.org/10.1145/3430025
      </p>

      <p>
        Hongyi Xu, Funshing Sin, Yufeng Zhu, and Jernej Barbič. 2015. Nonlinear Material Design Using Principal Stretches. <em>ACM Trans. Graph.</em> 34, 4, Article 75 (July 2015), 11 pages.
        https://doi.org/10.1145/2766917
      </p>

      <p>
        Juntao Ye, Guanghui Ma, Liguo Jiang, Lan Chen, Jituo Li, Gang Xiong, Xiaopeng Zhang, and Min Tang. 2017. A Unified Cloth Untangling Framework Through Discrete Collision Detection.
        <em>Computer Graphics Forum</em> 36, 7 (2017), 217–228. https://doi.org/10.1111/cgf.13287 arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1111/cgf.13287
      </p>

      <p>
        Cem Yuksel, Jonathan M. Kaldor, Doug L. James, and Steve Marschner. 2012. Stitch Meshes for Modeling Knitted Clothing with Yarn-Level Detail. <em>ACM Trans. Graph.</em> 31, 4, Article 37 (July
        2012), 12 pages. https://doi.org/10.1145/2185520.2185533
      </p>

      <p>
        Chongyao Zhao, Jinkeng Lin, Tianyu Wang, Hujun Bao, and Jin Huang. 2022b. Efficient and Stable Simulation of Inextensible Cosserat Rods by a Compact Representation.
        <em>Computer Graphics Forum</em> 41, 7 (2022). https://doi.org/10.1111/cgf.14701
      </p>

      <p>
        Yidong Zhao, Jinhyun Choo, Yupeng Jiang, Minchen Li, Chenfanfu Jiang, and Kenichi Soga. 2022a. A barrier method for frictional contact on embedded interfaces.
        <em>Computer Methods in Applied Mechanics and Engineering</em> 393 (Apr 2022), 114820. https://doi.org/10.1016/j.cma.2022.114820
      </p>

      <p>
        Changxi Zheng and Doug L. James. 2012. Energy-based Self-Collision Culling for Arbitrary Mesh Deformations. <em>ACM Transactions on Graphics (Proceedings of SIGGRAPH 2012)</em> 31, 4 (Aug.
        2012). http://www.cs.cornell.edu/projects/escc
      </p>
    </div>
    <p class="trans">收稿日期：2007 年 2 月 20 日；修订日期：2009 年 3 月 12 日；接受日期：2009 年 6 月 5 日</p>
    <p class="ori">Received 20 February 2007; revised 12 March 2009; accepted 5 June 2009</p>
  </body>
</html>
